/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * service-util.js
 * Created by wuyaoqian on 2020/3/6.
 */

const Util = module.exports = {
    /**
     * 根据 ParentClazz 动态生成一个指定名称为 clazzName 的子类
     * @param {ObjectConstructor} ParentClazz
     * @param {string} clazzName
     * @return {SubClazz}
     */
    createSubClazz (ParentClazz, clazzName) {
        // 定义一个子类
        let SubClazz = class SubClazz extends ParentClazz {};
        // 修改子类名称
        Object.defineProperty(SubClazz, 'name', {
            value: clazzName,
            configurable: true
        });
        // 重载子类的 toString 方法
        Object.defineProperty(SubClazz, 'toString', {
            value () {
                return `class ${SubClazz.name} extends ${ParentClazz.name} {}`;
            },
            configurable: true
        });
        // 返回动态生成好的子类
        return SubClazz;
    },
    /**
     * 服务静态类检测
     * @param {ObjectConstructor} SubClazz
     * @param {ObjectConstructor} RootClazz
     * @param {string} staticMethod
     */
    clazzCheck (SubClazz, RootClazz, staticMethod) {
        if (!SubClazz || (SubClazz !== RootClazz && !RootClazz.isPrototypeOf(SubClazz))) {
            throw new Error(`Do not change ${RootClazz.name}.${staticMethod} context`);
        }
    },
    /**
     * 服务静态类检测，并返回服务静态类的实例
     * @param {ObjectConstructor} SubClazz
     * @param {ObjectConstructor} RootClazz
     * @param {string} staticMethod
     * @param {array} constructorParams
     * @param {boolean} [onlyCheck]
     * @return {instance|null}
     */
    getInstance (SubClazz, RootClazz, staticMethod, constructorParams, onlyCheck) {
        Util.clazzCheck(SubClazz, RootClazz, staticMethod);
        if (!SubClazz.hasOwnProperty('services')) {
            if (onlyCheck) { return null; }
            Object.defineProperty(SubClazz, 'services', {value: {}});
        }
        return (SubClazz['services'][constructorParams[0]] || (
            onlyCheck ? null : (
                SubClazz['services'][constructorParams[0]] = new SubClazz(...constructorParams)
            )
        ));
    },
    /**
     * 服务类构造器检测
     * @param {ObjectConstructor} SubClazz
     * @param {ObjectConstructor} RootClazz
     * @param {string} name
     * @param {function} cb
     */
    constructorCheck (SubClazz, RootClazz, name, cb) {
        if (SubClazz) {
            // 构造器参数 name 的类型检测，目前是必须 string 类型
            if (!name || typeof name !== 'string') {
                throw new Error(`Error arguments name ( ${name} ) in ${SubClazz.name} constructor`);
            }
            // 必须使用 clazz 类的静态方法来创建实例（因为在 clazzServiceCheck 中会自动生成 services 属性）
            if (!SubClazz.hasOwnProperty('services')) {
                throw new Error(`Please use ${SubClazz.name}.publish(...) replace new ${SubClazz.name}(...)，[services]`);
            }
            // 必须使用 clazz 类的静态方法来返回已创建的实例，而不是再次使用 new 来创建与 name 同名的实例
            if (SubClazz.services[name]) {
                throw new Error(`Please use ${SubClazz.name}.publish(...) replace new ${SubClazz.name}(...), [name exist]`);
            }
            // 剩下的交回原始构造器处理
            cb.call(this);
        } else {
            throw new Error(`Please use ${RootClazz.name}.publish(...) replace ${RootClazz.name}(...)`);
        }
    }
};
