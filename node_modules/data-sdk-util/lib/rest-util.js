/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 辅助 Rest 请求的方法类
 * Created by wuyaoqian on 16/11/16.
 */

// const path = require('path');
const qs = require('qs');
const EventEmitter = require('events');
const ipUtil = require('./ip-util');
const localUtil = require('./local-util');
const ErrorCode = require('./error-code-util');
const DataSdkRest = require('data-sdk-rest');

const _translateSuccessData = function (data) {
    // private boolean success;
    // private String message;
    // private int errorCode;
    // private T result;
    // private List<T> resultList;
    // private ErrorType errorType;

    let ret = {
        success: true,
        data: data
    };
    if (data) {
        if (data.success === true && data.result !== undefined && data.resultList !== undefined) {
            // 鹰击的正常数据
            ret.data = data.result || data.resultList;
        } else if (data.success === false && data.errorCode) {
            // 鹰击的异常数据
            ret.success = false;
            ret.errorObj = {
                'errorCode': data.errorCode,
                'data': data
            };
        }
    }
    return ret;
};

// 浏览器的数据返回的默认句柄
const _browserResponseDefaultHandler = {
    success (browserResponse, data, restResp) {
        browserResponse.json({
            'success': true,
            'data': data
        });
    },
    error (browserResponse, errorCodeDesc, restResp) {
        browserResponse.json({
            'success': false,
            'msg': errorCodeDesc.msg
        });
    }
};

/**
 * 通用rest请求辅助方法
 * @param url {string}          请求url
 * @param opt {object}          辅助选项数据 {
 *      req, res 或 socket,                            为必包含对象
 *      username: '',                                  请求使用的临时用户名（错误情况下的日志记录之用）
 *      logParam: [],                                  指定哪个参数写入日志中（错误情况下的日志记录之用）
 *      arrayFormat: 'repeat'|'indices'|'brackets'     数组传递的格式
 * }
 * @param data {object}         传递的数据
 * @param callbacks {object}    回调函数 {
 *      error:   function(eventEmitter, errorCodeDesc, restResp){},
 *      success: function(eventEmitter, data){},
 * }
 * @returns {EventEmitter|*}
 * @private
 */
const _RequestHandler = function (url, opt, data, callbacks) {
    let logger = this[0];
    let restlerType = this[1];
    let method = this[2];
    let moreOpt = this[3];

    // 0. 尝试从 cls 中获取 req, res, socket
    opt = opt || {};

    // 兼容应用中未依赖 @component-util/cls-support 的应用（ 不在支持 2019-11-26 ）
    // let cls;
    // try { cls = require.resolve('@component-util/cls-support') } catch (e) {}
    // if (cls) {
    //     cls = require('@component-util/cls-support');
    //     let _req1 = opt.req, _req2 = cls.get('req');
    //     let _res1 = opt.res, _res2 = cls.get('res');
    //     let _socket1 = opt.socket, _socket2 = cls.get('socket');
    //     if (_req1 && _req2 && _req1 !== _req2) {
    //         logger.error(
    //              'CLS ERROR: opt.req !== cls.get("req"), sid-1: %s, sid-2: %s',
    //              (_req1.session || {}).id, (_req2.session || {}).id
    //         );
    //     }
    //     if (_res1 && _res2 && _res1 !== _res2) {
    //         logger.error(
    //            'CLS ERROR: opt.res !== cls.get("res"), header-send-1: %s,
    //            header-send-2: %s', _res1.headersSent, _res2.headersSent
    //         );
    //     }
    //     if (_socket1 && _socket2 && _socket1 !== _socket2) {
    //         logger.error(
    //            'CLS ERROR: opt.socket !== cls.get("socket"), csid-1: %s, csid-2: %s', _socket1.id, _socket2.id
    //         );
    //     }
    //     // 因发现在 cls 在使用过程中不太稳定，有时候会拿到其它的值（清掉 cookies 又可能临时恢复正常），所以这里暂时不用 2019-03-22
    //     // opt.req = opt.req || cls.get('req');
    //     // opt.res = opt.res || cls.get('res');
    //     // opt.socket = opt.socket || cls.get('socket');
    // }

    if (!opt || ((!opt.req || !opt.res) && !opt.socket)) {
        throw new Error(
            `RestHelp: 第二个参数中缺少变量 {
                req: 'browser request object', res: 'browser response object', socket: 'browser client socket'
            } `
        );
    }

    // 1.1 初始化参数
    let eventEmitter = new EventEmitter();
    let options = Object.assign({}, opt);
    let username, ip, lang;
    let arrayFormat = options.arrayFormat || 'repeat';
    let query = options.query;
    delete options.query;
    delete options.arrayFormat;

    options.headers = options.headers || {};
    options.username = options.username || options.loginUserName;
    if (options.req) {
        username = (DataSdkRest.userDataManage.session.userInfo.get(options.req.session) || {}).username;
        if (username && options.username) {
            // S: username in session, T: username for current request
            username = 'S:' + username + ', C:' + options.username;
        }
        username = username || options.username || 'unknown-rest';
        ip = ipUtil.getClientIp(options.req) || 'unknown-rest';
        lang = localUtil.getLangStr(options.req);
    } else if (options.socket) {
        username = (DataSdkRest.userDataManage.socketRequest.restInfo.get(options.socket.request) || {})
            .username || 'unknown-socket';
        ip = ipUtil.getClientIp(options.socket.request) || 'unknown-socket';
        lang = (DataSdkRest.userDataManage.socketRequest.restInfo.get(options.socket.request) || {}).lang;
    }
    delete options.loginUserName;
    delete options.username;

    if (method === 'auto' && options.req) {
        method = options.req.method.toLowerCase();
    }
    if (method === 'auto' && options.socket) {
        throw new Error('在 socket 中调用 rest 方法，不能指定 method 为 auto!');
    }

    // 1.2 构造 options.data 参数
    if (data) {
        if (typeof (data) !== 'object') {
            throw new Error('第三个参数 (data) 的格式不正确 (必须为 object或null或undefined )', data);
        }
        if (!Array.isArray(data)) {
            Object.keys(data).forEach(function (key) {
                if (
                    data[key] === undefined ||
                    data[key] === null ||
                    (typeof data[key] === 'number' && isNaN(data[key]))
                ) {
                    // 去掉无效的参数
                    delete data[key];
                } else if (/^{[^{}]+}$/.test(key)) {
                    // 适配路径参数
                    url = url.replace(new RegExp(key, 'ig'), encodeURIComponent(data[key]));
                    delete data[key];
                }
            });
        }
        if (method === 'get' || method === 'head' || method === 'del' || method === 'delete') {
            query = Object.assign({}, query, data);
        } else if (method === 'post' || method === 'put') {
            if (options.headers['Content-Type'] === 'application/json') {
                options.data = JSON.stringify(data);
            } else {
                options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                options.data = qs.stringify(data, { arrayFormat: arrayFormat });
            }
        } else {
            options.data = data;
        }
    }

    // 1.3 构造 options.query 参数
    if (query && typeof query === 'object') {
        if (/\?[^?]+$/.test(url)) {
            // 因 options.query 与 url.query 在 restler 中存在冲突，所以这里强行将 options.query 并入到 url.query
            url = `${url.replace(/&+$/g, '')}&${qs.stringify(query, { arrayFormat: arrayFormat })}`;
        } else {
            // 不存在 url.query 的情况下，提前将 options.query 编码
            options.query = qs.stringify(query, { arrayFormat: arrayFormat });
        }
    }

    // 1.4 整合额外 opt 参数
    if (moreOpt) {
        options = Object.assign(options, moreOpt);
    }

    // 2. 如果未拦截相应的事件，则这里会自动的处理浏览器的返回数据 (在下一个处理链中处理，注意：2，4 的顺序不能反了; 与 process.nextTick 的执行顺序有关)
    process.nextTick(() => {
        if (!eventEmitter.listenerCount('success') && options.res) {
            eventEmitter.on('success', (data, restResp) => {
                _browserResponseDefaultHandler.success(options.res, data, restResp);
            });
        }
        if (!eventEmitter.listenerCount('error') && options.res) {
            eventEmitter.on('error', (errorCodeDesc, restResp) => {
                _browserResponseDefaultHandler.error(options.res, errorCodeDesc, restResp);
            });
        }
    });

    // 3. 请求服务器
    let urlLogOpt = {
        username: username,
        ip: ip,
        method: method,
        params: undefined
    };
    if (data && options.logParam && Array.isArray(options.logParam) && options.logParam.length) {
        urlLogOpt.params = {};
        options.logParam.forEach((key) => {
            urlLogOpt.params[key] = data[key];
        });
    }
    delete options.logParam;
    DataSdkRest[restlerType][method](url, options).on('error', function (errorObj, restResp) {
        ErrorCode.loggerUrlErrorMsg(logger, url, 'error', errorObj, urlLogOpt, restResp);
        if (callbacks && typeof callbacks.error === 'function') {
            callbacks.error.call(this, eventEmitter, ErrorCode.getErrorCodeDesc(errorObj, lang), restResp);
        } else {
            eventEmitter.emit('error', ErrorCode.getErrorCodeDesc(errorObj, lang), restResp);
        }
    }).on('fail', function (errorObj, restResp) {
        ErrorCode.loggerUrlErrorMsg(logger, url, 'fail', errorObj, urlLogOpt, restResp);
        if (callbacks && (typeof callbacks.fail === 'function' || typeof callbacks.error === 'function')) {
            (typeof callbacks.fail === 'function' ? callbacks.fail : callbacks.error).call(
                this, eventEmitter, ErrorCode.getErrorCodeDesc(errorObj, lang), restResp
            );
        } else {
            eventEmitter.emit('error', ErrorCode.getErrorCodeDesc(errorObj, lang), restResp);
        }
    }).on('success', function (data, restResp) {
        let ret = _translateSuccessData(data);
        if (ret.success) {
            if (callbacks && typeof callbacks.success === 'function') {
                callbacks.success.call(this, eventEmitter, ret.data, restResp);
            } else {
                eventEmitter.emit('success', ret.data, restResp);
            }
        } else {
            ErrorCode.loggerUrlErrorMsg(logger, url, 'error', ret.errorObj, urlLogOpt, restResp);
            if (callbacks && typeof callbacks.error === 'function') {
                callbacks.error.call(
                    this, eventEmitter, ErrorCode.getErrorCodeDesc(ret.errorObj, lang), restResp
                );
            } else {
                eventEmitter.emit('error', ErrorCode.getErrorCodeDesc(ret.errorObj, lang), restResp);
            }
        }
    });

    // 4. 返回 emitter
    return eventEmitter;
};

class RestlerHelp {
    constructor (array, args) {
        this._logger_ = array[0];
        this._type_ = array[1];
        this._method_ = array[2];
        this._moreOpt_ = array[3];
        this._args_ = args;
        this._opt = { headers: {} };
        this._data = null;
        this._callback = {};
    }

    opt (opt) {
        if (opt && opt.headers) {
            this.header(opt.headers);
            delete opt.headers;
        }
        this._opt = Object.assign(this._opt, opt);
        return this;
    }

    header (header) {
        if (typeof header === 'function') {
            header = header();
        }
        if (header && typeof header === 'object') {
            this._opt.headers = Object.assign(this._opt.headers, header);
        }
        return this;
    }

    query (data) {
        if (typeof data === 'function') {
            data = data();
        }
        if (data && typeof data === 'object') {
            this._opt.query = Object.assign(this._opt.query || {}, data);
        }
        return this;
    }

    data (data) {
        if (typeof data === 'function') {
            data = data();
        }
        if (data && typeof data === 'object') {
            this._data = Object.assign(this._data || {}, data);
        }
        return this;
    }

    success (fn) {
        this._callback.success = fn;
        return this;
    }

    error (fn) {
        this._callback.error = fn;
        return this;
    }

    fail (fn) {
        this._callback.fail = fn;
        return this;
    }

    expired (fn) {
        this._callback.expired = fn;
        return this;
    }

    send () {
        return _RequestHandler.apply([this._logger_, this._type_, this._method_, this._moreOpt_], [
            this._args_[0], this._opt, this._data, this._callback
        ]);
    }
}

class Restler {
    constructor (logger, type) {
        this.logger = logger;
        this.type = type;
    }

    _base (method, moreOpt, args) {
        let restlerHelp = new RestlerHelp([this.logger, this.type, method, moreOpt], args);
        if (args.length !== 1) {
            let cb = args[3] || {};
            return restlerHelp.opt(args[1]).data(args[2])
                .success(cb.success).error(cb.error).fail(cb.fail).expired(cb.expired)
                .send();
        }
        return restlerHelp;
    }

    get () { return this._base('get', null, arguments); }

    head () { return this._base('head', null, arguments); }

    del () { return this._base('del', null, arguments); }

    post () { return this._base('post', null, arguments); }

    put () { return this._base('put', null, arguments); }

    download () { return this._base('get', { 'pipe-response': true }, arguments); }

    upload () { return this._base('post', { 'pipe-upload': true }, arguments); }

    auto () { return this._base('auto', null, arguments); }

    pipe () {
        return this._base('auto', {
            'pipe-upload': true,
            'pipe-response': true
        }, arguments);
    }
}

const RestHelp = function (logger) {
    return RestHelp.getInstance(logger);
};

// 获取一个实例
RestHelp.getInstance = function (logger) {
    if (!logger) {
        throw new Error('logger is required in RestHelp');
    }

    return {
        userSocketRest: new Restler(logger, 'socketUserTokenRestler'),
        userRest: new Restler(logger, 'userTokenRestler'),
        appRest: new Restler(logger, 'appTokenRestler'),
        baseRest: new Restler(logger, 'baseRestler')
    };
};

// 暴露默认方法
RestHelp.browserResponseDefaultHandler = _browserResponseDefaultHandler;

/**
 * 通用Rest请求工具, 使用方法如下:
 *
 * var RestHelp = require("path to RestHelp")(logger);
 * var newEventEmitter = RestHelp.userRest.get(url, opt, data, callbacks);
 * var newEventEmitter = RestHelp.userRest.post(url, opt, data, callbacks);
 * var newEventEmitter = RestHelp.appRest.download(url, opt, data, callbacks);
 * var newEventEmitter = RestHelp.appRest.upload(url, opt, data, callbacks);
 *
 * or
 *
 * var newEventEmitter = RestHelp.appRest.get(url).opt({}).data({}).success(function(){}).error(function(){}).send();
 *
 * @type {Function}
 */
module.exports = RestHelp;
