/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 推送连接管理
 * Created by wuyaoqian on 2017/1/18.
 */

const EventEmitter = require('events');
const SocketIO = require('socket.io-client');
const DataSdkRest = require('data-sdk-rest');
const TokenProvider = DataSdkRest.tokenProvider;
const logger = require('log4js-config').get('eefung.data-sdk-socket.' + require('path').basename(__filename));

// 常量
const ConnectProgress = Symbol('ConnectProgress');
const RegistServerSocketEvent = Symbol('RegistServerSocketEvent');
const PushConnect = Symbol('PushConnect');

// 在推送当中对外抛出的一些公共事件
const globalEvent = new EventEmitter();

/**
 * 推送连接管理
 *      tryConnect: function(baseUrl, namespace, token){}
 * }
 */
const ConnectManage = {
    [ConnectProgress]: {},

    /**
     * 注册 server socket 的相关事件
     * @param socket {object} server socket
     * @param pushServerUrl {string} eg: http://172.19.104.120:9093/topic-monitor
     * @return {EventEmitter} {
     *      success: function(socket){},
     *      error: function(){}
     * }
     * @private
     */
    [RegistServerSocketEvent]: function (socket, pushServerUrl) {
        if (socket._emitter) {
            return socket._emitter;
        } else {
            socket._connect_success_times = 0;
        }
        const emitter = socket._emitter = new EventEmitter();
        const removeListeners = () => {
            emitter.removeAllListeners('success');
            emitter.removeAllListeners('error');
            emitter.on('error', () => {});
        };
        const sendConnectionOffEvents = (type, reason) => {
            // 只在连接成功后的断开连接，才会抛出此事件
            if (!emitter.listenerCount('success')) {
                globalEvent.emit('server-disconnected', socket, {
                    type,
                    reason
                });
            }
        };

        // 1. 注册事件 - 首次或者以后的重连的连接成功
        socket.on('connect', () => {
            socket._connect_success_times += 1;
            if (socket._connect_success_times === 1) {
                logger.info('successfully established to push server(url: %s, sid: %s)', pushServerUrl, socket.id);
            } else {
                logger.info(
                    'successfully re-established to push server(url: %s, sid: %s) times: %s',
                    pushServerUrl, socket.id, socket._connect_success_times
                );
            }
            emitter.emit('success', socket);
            removeListeners();
        });

        // 2. 注册事件 - 其他连接出错
        socket.on('error', (reason) => {
            logger.error('push server(%s) connect error (type: error): ', pushServerUrl, reason);
            emitter.emit('error');
            sendConnectionOffEvents('error', reason);
            removeListeners();
        });

        // 3. 注册事件 - 连接出错
        socket.on('connect_error', (reason) => {
            logger.error('push server(%s) connect error (type: connect_error): ', pushServerUrl, reason);
            emitter.emit('error');
            sendConnectionOffEvents('connect_error', reason);
            removeListeners();
        });

        // 4. 注册事件 - 断开连接
        socket.on('disconnect', () => {
            logger.error('push server(%s) was disconnected.', pushServerUrl);
            emitter.emit('error');
            sendConnectionOffEvents('disconnect');
            removeListeners();
        });

        return emitter;
    },
    /**
     * 开始连接
     * @param socket
     * @param pushServerUrl
     * @param token
     * @return {Promise}
     */
    [PushConnect]: (socket, pushServerUrl, token) => {
        return new Promise((resolve, reject) => {
            // 1. 监听已注册的事件
            ConnectManage[RegistServerSocketEvent](socket, pushServerUrl).on('success', function (socket) {
                clearTimeout(socket._custom_timeout);
                resolve(socket);
            }).on('error', () => {
                clearTimeout(socket._custom_timeout);
                // eslint-disable-next-line prefer-promise-reject-errors
                reject();
            });

            // 2. 自定义请求超时, 主要是需要解决未知原因导致 connect、error、connect_error、disconnect 中的一个事件都没有抛出的问题
            socket._custom_timeout = setTimeout(() => {
                logger.error('push server(%s) connect error (type: custom-timeout): ', pushServerUrl);
                socket.destroy();
                // eslint-disable-next-line prefer-promise-reject-errors
                reject();
            }, 1000 * (15 + 10));

            // 3. 在连接前，设置新的 access_token
            socket.io.opts.query = 'access_token=' + token.access_token;

            // 4. 开始尝试连接
            logger.debug('start connecting push server(%s)', pushServerUrl);
            socket.connect();
        });
    },
    /**
     * 尝试连接推送服务器
     * @param baseUrl {string}      eg: http://172.19.104.120:9093
     * @param namespace {string}    eg: /topic-monitor
     * @return {Promise} {
     *      resolve: function(socket){},
     *      reject: function(){}
     * }
     */
    tryConnect: (baseUrl, namespace) => {
        let socket, client;
        let self = ConnectManage;
        let pushServerUrl = baseUrl + namespace;
        if (self[ConnectProgress][pushServerUrl]) {
            return self[ConnectProgress][pushServerUrl];
        }
        client = SocketIO.managers[baseUrl];
        return (self[ConnectProgress][pushServerUrl] = new Promise((resolve, reject) => {
            // 1. 生成或获取 server socket
            if (!client || !(socket = client.nsps[namespace])) {
                socket = SocketIO(pushServerUrl, {
                    transports: ['websocket'],
                    timeout: 1000 * 15,
                    reconnection: false,
                    autoConnect: false
                });
            }

            // 2. 检测当前获取到的 server socket 是否已经处于连接状态，是则直接返回，并抛出成功事件
            // 注意：此时 serverSocket 抛出的 disconnect, error 等中断事件，将不会在 第3点处执行（因为事件已被清理了）
            if (socket.connected) {
                return process.nextTick(() => {
                    delete self[ConnectProgress][pushServerUrl];
                    resolve(socket);
                });
            }

            // 3. 获取 AppToken
            TokenProvider.fetchAppToken(false, true).then((token) => {
                return self[PushConnect](socket, pushServerUrl, token);
            }, ({ type, data }) => {
                return Promise.reject(new Error(`fetchAppToken catch ${type} error, timeout: ${data / 1000}s`));
            }).then((socket) => {
                delete self[ConnectProgress][pushServerUrl];
                resolve(socket);
            }).catch((error) => {
                delete self[ConnectProgress][pushServerUrl];
                reject(error || new Error(`push connect catch error, url: ${pushServerUrl}`));
            });
        }));
    }

};

module.exports = {
    /**
     * 抛出的一些公共事件
     * 1. server-disconnected                // function(serverSocket, {type, reason}){}
     */
    events: globalEvent,
    tryConnect: ConnectManage.tryConnect // function(baseUrl, namespace, token){}
};
