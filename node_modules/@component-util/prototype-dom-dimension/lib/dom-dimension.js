/*!
 * Copyright (c) 2010-2017 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2017 湖南蚁坊软件股份有限公司。保留所有权利。
 */

"use strict";

/**
 * dom-dimension.js (chrome, firefox, ie9及以上)
 * 使用方法：
 * import '@component-util/dom-dimension';
 *
 * var dom = document.getElementById('id');
 *
 * // 获取宽度值：内容宽度
 * dom.getWidth()
 * // 获取宽度值：内容宽度 + Padding左右宽度值
 * dom.getWidth(1) or dom.getWidth("padding")
 * // 获取宽度值：内容宽度 + Padding左右宽度值 + Border左右宽度值
 * dom.getWidth(2) or dom.getWidth("border")
 * // 获取宽度值：内容宽度 + Padding左右宽度值 + Border左右宽度值 + Margin左右宽度值
 * dom.getWidth(3) or dom.getWidth("margin")
 *
 * // 获取高度值：内容高度
 * dom.getHeight()
 * // 获取高度值：内容高度 + Padding上下宽度值
 * dom.getHeight(1) or dom.getHeight("padding")
 * // 获取高度值：内容高度 + Padding上下宽度值 + Border上下宽度值
 * dom.getHeight(2) or dom.getHeight("border")
 * // 获取高度值：内容高度 + Padding上下宽度值 + Border上下宽度值 + Margin上下宽度值
 * dom.getHeight(3) or dom.getHeight("margin")
 *
 * // 获取 dom 元素的相对位置
 * dom.getOffset()
 *
 * // 获取 dom 元素的相对位置
 * dom.getPosition()
 *
 * Created by wuyaoqian on 2017/9/28.
 */

/**
 * 获取 dom 元素的宽度值
 * @param type {string | int} 宽度值的类型，具体值如下：
 * type = undefined || 0: content-width
 * type = padding || 1:   content-width + padding-width
 * type = border || 2:    content-width + padding-width + border-width
 * type = margin || 3:    content-width + padding-width + border-width + margin-width
 * @return {Number}
 */
Element.prototype.getWidth = function (type) {
    let cs = window.getComputedStyle(this);
    let width = parseInt(cs['width']);

    // content-width
    if (cs['box-sizing'] === 'border-box') {
        width -= parseInt(cs['border-left-width']);
        width -= parseInt(cs['padding-left']);
        width -= parseInt(cs['padding-right']);
        width -= parseInt(cs['border-right-width']);
    }

    // content-width + padding-width
    if (type === 'padding' || type === 1 || type === 'border' || type === 2 || type === 'margin' || type === 3) {
        width += parseInt(cs['padding-left']);
        width += parseInt(cs['padding-right']);
    }

    // content-width + padding-width + border-width
    if (type === 'border' || type === 2 || type === 'margin' || type === 3) {
        width += parseInt(cs['border-left-width']);
        width += parseInt(cs['border-right-width']);
    }

    // content-width + padding-width + border-width + margin-width
    if (type === 'margin' || type === 3) {
        width += parseInt(cs['margin-left']);
        width += parseInt(cs['margin-right']);
    }

    return width;
};

/**
 * 获取 dom 元素的高度值
 * @param type {string | int} 宽度值的类型，具体值如下：
 * type = undefined || 0: content-height
 * type = padding || 1:   content-height + padding-width
 * type = border || 2:    content-height + padding-width + border-width
 * type = margin || 3:    content-height + padding-width + border-width + margin-width
 * @return {Number}
 */
Element.prototype.getHeight = function (type) {
    let cs = window.getComputedStyle(this);
    let height = parseInt(cs['height']);

    // content-height
    if (cs['box-sizing'] === 'border-box') {
        height -= parseInt(cs['border-top-width']);
        height -= parseInt(cs['padding-top']);
        height -= parseInt(cs['padding-bottom']);
        height -= parseInt(cs['border-bottom-width']);
    }

    // content-height + padding-width
    if (type === 'padding' || type === 1 || type === 'border' || type === 2 || type === 'margin' || type === 3) {
        height += parseInt(cs['padding-top']);
        height += parseInt(cs['padding-bottom']);
    }

    // content-height + padding-width + border-width
    if (type === 'border' || type === 2 || type === 'margin' || type === 3) {
        height += parseInt(cs['border-top-width']);
        height += parseInt(cs['border-bottom-width']);
    }

    // content-height + padding-width + border-width + margin-width
    if (type === 'margin' || type === 3) {
        height += parseInt(cs['margin-top']);
        height += parseInt(cs['margin-bottom']);
    }

    return height;
};

/**
 * 获取元素的相对位置
 * @return {{top: number, left: number}}
 */
Element.prototype.getOffset = function () {
    let elem = this;
    let win = window;
    let box = {
        top: 0,
        left: 0
    };
    let doc = elem && elem.ownerDocument;
    let docElem = doc.documentElement;
    // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)
    if (typeof elem.getBoundingClientRect !== undefined) {
        box = elem.getBoundingClientRect();
    }
    return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
    };
};

/**
 * 获取元素的绝对位置
 * @return {{top: number, left: number}}
 */
Element.prototype.getPosition = function () {
    let gcs = window.getComputedStyle;
    let tcs = gcs(this);
    let offsetParent, offset;
    let elem = this;
    let parentOffset = {
        top: 0,
        left: 0
    };
    let getOffsetParent = function () {
        let docElem = window.document.documentElement;
        let offsetParent = elem.offsetParent || docElem;
        while (offsetParent && (offsetParent.nodeName.toLowerCase() !== 'html') && gcs(offsetParent)['position'] === 'static') {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
    };
    // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
    if (tcs['position'] === 'fixed') {
        // We assume that getBoundingClientRect is available when computed position is fixed
        offset = elem.getBoundingClientRect();
    } else {
        // Get *real* offsetParent
        offsetParent = getOffsetParent();
        // Get correct offsets
        offset = this.getOffset();
        if (offsetParent.nodeName.toLowerCase() !== 'html') {
            parentOffset = offsetParent.getOffset();
        }
        // Add offsetParent borders
        parentOffset.top += parseInt(gcs(offsetParent)['border-top-width']);
        parentOffset.left += parseInt(gcs(offsetParent)['border-left-width']);
    }
    // Subtract parent offsets and element margins
    return {
        top: offset.top - parentOffset.top - parseInt(tcs['margin-top']),
        left: offset.left - parentOffset.left - parseInt(tcs['margin-left'])
    };
};
