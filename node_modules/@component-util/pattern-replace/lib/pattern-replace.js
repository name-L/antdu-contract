/*!
 * Copyright (c) 2010-2018 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2018 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

const extend = require('deep-extend');

/**
 * string-replace.js
 * Created by wuyaoqian on 2018/5/22.
 */

/**
 * 模式内容替换
 * @param content {string} 原始内容
 * @param data {object} 需要替换的对象
 * @param options {object} 选项 {
 *      // 当在 data 中未找到相应的内容时的替换决策（是否保留原始值，如果不保留将使用空字符串代替）
 *      reservePatternWhenDataEmpty: false,
 *      // 被替换的模式对描述
 *      pattern: {
 *          start: '{',
 *          end: '}',
 *          double: true
 *      }
 * }
 * @return {*}
 */
module.exports = function (content, data, options) {
    let patternRet;
    let p1Ret;
    let p2Ret;
    let opt = extend({
        reservePatternWhenDataEmpty: false,
        pattern: {
            start: '{',
            end: '}',
            double: true
        }
    }, options);
    let _start_ = opt.pattern.double ? (opt.pattern.start + opt.pattern.start) : opt.pattern.start;
    let _end_ = opt.pattern.double ? (opt.pattern.end + opt.pattern.end) : opt.pattern.end;
    // str = "test{{data}}test";
    // ret[0] = "{{data}}";
    // ret[1] = "data";
    let pattern1 = new RegExp(`${_start_}([^${opt.pattern.start}${opt.pattern.end}]+)${_end_}`, 'g');
    let pattern2 = [
        {
            // str = "data.abc.efg";
            // ret[1] = "data";
            // ret[2] = ".abc.efg";
            p1: /^([^.[\]-]+)((\.[^.-]+)+)$/,
            // str = ".abc.efg";
            // ret[1] = ".";
            // ret[2] = "abc";
            // ... repeat 1,2
            p2: /(\.)([^.-]+)/g
        },
        {
            // str = "data['abc'][0]";
            // ret[1] = "data";
            // ret[2] = "['abc'][0]";
            p1: /^([^.['"\]]+)((\[(['"]?)[^['"\].]+\4])+)$/,
            // str = "['abc'][0]";
            // ret[1] = "'";
            // ret[2] = "abc";
            // ... repeat 1,2
            p2: /\[(['"]?)([^['"\].]+)\1]/g
        }
    ];
    let newContent = content;
    let isFound;
    let replacement;
    while ((patternRet = pattern1.exec(content))) {
        isFound = pattern2.find((expObj) => {
            p1Ret = expObj.p1.exec(patternRet[1]);
            if (p1Ret) {
                replacement = data[p1Ret[1]] || null;
                while (replacement && (p2Ret = expObj.p2.exec(p1Ret[2]))) {
                    replacement = replacement[p2Ret[2]];
                }
                expObj.p2.lastIndex = 0;
                return true;
            }
        });
        if (!isFound) {
            replacement = data[patternRet[1]];
        }
        newContent = newContent.replace(patternRet[0], replacement || (() => {
            if (typeof replacement === 'string' || typeof replacement === 'number') {
                return replacement;
            }
            return opt.reservePatternWhenDataEmpty ? patternRet[0] : '';
        })());
    }
    pattern1.lastIndex = 0;
    return newContent;
};