/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

const http = require('http');
const https = require('https');
const Url = require('url');
const EE = require('events');

/**
 * socket-pipe.js
 * @see https://github.com/nodejitsu/node-http-proxy#readme
 * Created by wuyaoqian on 2018/12/26.
 */

const Util = {
    /**
     * 设置 socket 为长连接类型
     * @param socket
     * @return {*}
     */
    setupWebSocket: function (socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
    },
    /**
     * 生成请求头
     * @param line
     * @param headers
     * @return {string}
     */
    createHttpHeader: function (line, headers) {
        return Object.keys(headers).reduce(function (head, key) {
            let value = headers[key];
            if (!Array.isArray(value)) {
                head.push(key + ': ' + value);
                return head;
            }
            for (let i = 0; i < value.length; i++) {
                head.push(key + ': ' + value[i]);
            }
            return head;
        }, [line]).join('\r\n') + '\r\n\r\n';
    },
    /**
     * 检测是否是标准的请求方式
     * @param req
     * @param socket
     * @return {boolean}
     */
    checkMethodAndHeader: function (req, socket) {
        if (req.method !== 'GET' || !req.headers.upgrade) {
            socket.destroy();
            return true;
        }
        if (req.headers.upgrade.toLowerCase() !== 'websocket') {
            socket.destroy();
            return true;
        }
    },
    /**
     * 组装 url
     * @param {Url} url
     * @return {*|string|string}
     */
    fullPath: function (url) {
        let path = url.pathname || '/';
        if (url.hash) path += url.hash;
        if (url.query) path += '?' + url.query;
        return path;
    }
};

/**
 * websocket pipe
 * @param {IncomingMessage} sourceRequest
 * @param {net.Socket} sourceSocket
 * @param {Buffer} sourceHead
 * @param {Object} options
 * @param {String} options.url
 * @param {String|undefined} options.method
 * @param {Object|undefined} options.header
 * @param {Object|undefined} options.agent
 * @return {*|void|number}
 */
const pipe = function (sourceRequest, sourceSocket, sourceHead, options) {
    Util.setupWebSocket(sourceSocket);

    // init targetRequest
    let url = Url.parse(options.url);
    let targetRequest = (/^https|wss/.test(url.protocol) ? https : http).request({
        host: url.hostname,
        port: url.port,
        path: Util.fullPath(url),
        method: options.method || sourceRequest.method,
        headers: Object.assign({}, sourceRequest.headers, {
            'host': url.host
        }, options.header),
        agent: options.agent
    });
    let emitter = new EE();
    let processError = function (error) {
        emitter.emit('error', error);
        sourceSocket.end();
    };

    if (sourceHead && sourceHead.length) { sourceSocket.unshift(sourceHead); }

    // Error Handler
    targetRequest.on('error', processError);
    targetRequest.on('response', function (targetResponse) {
        // if upgrade event isn't going to happen, close the socket
        if (!targetResponse.upgrade) {
            sourceSocket.write(
                Util.createHttpHeader(
                    `HTTP/${targetResponse.httpVersion} ${targetResponse.statusCode} ${targetResponse.statusMessage}`,
                    targetResponse.headers
                )
            );
            targetResponse.pipe(sourceSocket);
        }
    });

    // upgrade handler
    targetRequest.on('upgrade', function (targetResponse, targetSocket, targetHead) {
        Util.setupWebSocket(targetSocket);
        targetSocket.on('error', processError);
        targetSocket.on('end', function () {
            emitter.emit('close', targetResponse, targetSocket);
        });

        // The pipe below will end proxySocket if socket closes cleanly, but not
        // if it errors (eg, vanishes from the net and starts returning
        // EHOSTUNREACH). We need to do that explicitly.
        sourceSocket.on('error', function () {
            targetSocket.end();
        });

        if (targetHead && targetHead.length) targetSocket.unshift(targetHead);

        //
        // Remark: Handle writing the headers to the socket when switching protocols
        // Also handles when a header is an array
        //
        sourceSocket.write(Util.createHttpHeader('HTTP/1.1 101 Switching Protocols', targetResponse.headers));
        targetSocket.pipe(sourceSocket).pipe(targetSocket);

        // watch targetSocket response data before pipe to sourceSocket
        if (emitter.listenerCount('data-response')) {
            targetSocket.removeAllListeners('data');
            targetSocket.on('data', function (chunk) {
                emitter.emit('data-response', Buffer.from(chunk), function (newChunk) {
                    // console.debug('data-response-raw:', newChunk && newChunk.length, newChunk, chunk.length, chunk);
                    if (sourceSocket.writable) {
                        if (
                            sourceSocket.write((newChunk && Buffer.isBuffer(newChunk)) ? newChunk : chunk) === false &&
                            targetSocket.pause
                        ) {
                            targetSocket.pause();
                        }
                    }
                });
            });
        }

        // watch sourceSocket request data before pipe to targetSocket
        if (emitter.listenerCount('data-request')) {
            sourceSocket.removeAllListeners('data');
            sourceSocket.on('data', function (chunk) {
                emitter.emit('data-request', Buffer.from(chunk), function (newChunk) {
                    // console.debug('data-request-raw:', newChunk && newChunk.length, newChunk, chunk.length, chunk);
                    if (targetSocket.writable) {
                        if (
                            targetSocket.write((newChunk && Buffer.isBuffer(newChunk)) ? newChunk : chunk) === false &&
                            sourceSocket.pause
                        ) {
                            sourceSocket.pause();
                        }
                    }
                });
            });
        }

        emitter.emit('open', targetResponse, targetSocket);
    });

    // XXX: CHECK IF THIS IS THIS CORRECT
    targetRequest.end();
    return emitter;
};

// 暴露 Util 中的各方法
Object.assign(pipe, Util);

module.exports = pipe;
