/*!
 * Copyright (c) 2010-2017 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2017 湖南蚁坊软件有限公司。保留所有权利。
 */

"use strict";

/**
 * 周期性推送
 * 使用方法:
 * import PushManage from '@component-util/socket-push';
 *
 * const socket = PushManage.getPushServer("/test");
 * const timer = new PushManage.PushTimer(socket, 30000, {
 *      key, val, ack
 * }, {
 *      key, val, ack
 * });
 *
 * // 1. 开始
 * timer.start();
 *
 * // 2. 停止
 * timer.stop();
 *
 * Created by wuyaoqian on 2017-9-21.
 */
class PushTimer {
    /**
     * @param socket {Socket} 推送长连接对象
     * @param period {int} 指令的发送周期
     * @param startEmitParamObj {object} {
     *      key: "",
     *      val: {} || function(){},
     *      ack: undefined || function(){}
     * }
     * @param stopEmitParamObj {object || undefined} {
     *      key: "",
     *      val: {} || function(){}
     *      ack: undefined || function(){}
     * }
     */
    constructor(socket, period, startEmitParamObj, stopEmitParamObj) {
        this.socket = socket;
        this.period = period || 1000 * 30;
        this.emitObj = {
            start: {
                key: startEmitParamObj.key,
                val: typeof startEmitParamObj.val === "function" ? startEmitParamObj.val : function () {
                    return startEmitParamObj.val || {};
                },
                ack: startEmitParamObj.ack
            },
            stop: stopEmitParamObj ? {
                key: stopEmitParamObj.key,
                val: typeof stopEmitParamObj.val === "function" ? stopEmitParamObj.val : function () {
                    return stopEmitParamObj.val || {};
                },
                ack: stopEmitParamObj.ack
            } : null
        };

        this._timeoutid_ = 0;
        this._stoped_ = false;
        this._latest_ = {
            time: 0,
            type: null
        };
    }

    _periodFN_(now) {
        if (this._stoped_) { return; }
        clearTimeout(this._timeoutid_);
        this._timeoutid_ = setTimeout(() => {
            if (this._stoped_) { return; }
            this.socket.emit(this.emitObj.start.key, this.emitObj.start.val(), this.emitObj.start.ack);
            this._latest_.time = Date.now();
            this._latest_.type = 'start';
            this._periodFN_();
        }, now ? 0 : this.period);
    }

    /**
     * 开始周期性发送指令
     * @param now {boolean} 是否立即发送，或等下一个周期
     */
    start(now) {
        this._stoped_ = false;
        this._periodFN_(now);
    }

    /**
     * 停止周期性发送指令
     */
    stop() {
        this._stoped_ = true;
        clearTimeout(this._timeoutid_);
        if (this.emitObj.stop) {
            this.socket.emit(this.emitObj.stop.key, this.emitObj.stop.val(), this.emitObj.stop.ack);
            this._latest_.time = Date.now();
            this._latest_.type = 'stop';
        }
    }

    /**
     * 获取最近一次发送的指令状态
     */
    status() {
        return this._latest_;
    }
}

export default PushTimer;
