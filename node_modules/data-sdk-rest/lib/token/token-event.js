/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * token-events.js
 * Created by wuyaoqian on 2018/1/10.
 */

const EventEmitter = require('events');
const UserDataManage = require('../user/user-data.store.js');
const logger = require('log4js-config').get('eefung.data-sdk-rest.' + require('path').basename(__filename));

const Listener = Symbol('Listener');

const Util = {
    /**
     * 检测 context 参数的有效性
     * @param context
     * @return {boolean}
     */
    check (context) {
        if (context && context.req && context.res) { return true; }
        if (context && context.socket) { return true; }
        if (!context) {
            logger.error('check context was ', context);
        }
        if ((context.req && !context.res) || (!context.req && context.res)) {
            logger.error('check context.req(%s) or context.res(%s) false', !!context.req, !!context.res);
        }
        return false;
    }
};

class TokenEvent {
    constructor () {
        this[Listener] = new EventEmitter();
    }

    on (key, fn) {
        this[Listener].on(key, fn);
        return this;
    }

    /**
     * 0. 在 session 中验证 token（远程获取一次最新数据）
     * @param context {object}
     * @param token {AccessToken}
     * @return {Promise}
     */
    checkTokenInRemoteSession (context, token) {
        if (!Util.check(context) || !token) {
            return Promise.reject(new Error('checkTokenInRemoteSession: context or token param error'));
        }
        const fn = function (resolve, reject, token, error, sess) {
            if (error) { return reject(error); }
            if (!sess) { return reject(new Error('checkTokenInRemoteSession: failed to fetch session')); }
            let newToken = UserDataManage.session.userToken.get(sess);
            if (newToken &&
                newToken.access_token && newToken.access_token !== token.access_token &&
                newToken.refresh_token && newToken.refresh_token !== token.refresh_token) {
                return resolve(newToken);
            } else {
                return reject(new Error('checkTokenInRemoteSession: newToken data not expected'));
            }
        };
        return new Promise(function (resolve, reject) {
            // 延迟一段时间，再获取 session 数据
            setTimeout(function () {
                if (context.req && context.req.session && context.req.sessionStore) {
                    context.req.sessionStore.get(context.req.session.id, fn.bind(null, resolve, reject, token));
                } else if (context.socket && context.socket.request) {
                    let restInfo = UserDataManage.socketRequest.restInfo.get(context.socket.request);
                    restInfo['session-store'].get(restInfo.sid, fn.bind(null, resolve, reject, token));
                } else {
                    return reject(new Error('checkTokenInRemoteSession: context error'));
                }
            }, 3000);
        });
    }

    /**
     * 1. user token 刷新
     * @param context {object}
     * @param token {AccessToken}
     * @return
     */
    fireTokenRefreshed (context, token) {
        let self = this;
        if (!Util.check(context) || !token) { return; }
        if (context.req && context.req.session) {
            UserDataManage.session.userToken.set(
                context.req.session, token
            );
            // 立即保存，可大概率的减少其它节点获取旧token的问题
            context.req.session.save();
            return process.nextTick(() => {
                self[Listener].emit('token-refreshed', context, token);
            });
        }
        if (context.socket && context.socket.request) {
            let restInfo = UserDataManage.socketRequest.restInfo.get(context.socket.request);
            let session = context.session || context.socket_session || context.socket.session;
            if (session) {
                UserDataManage.session.userToken.set(
                    session, token
                );
                return restInfo['session-store'].set(restInfo.sid, session, function (err) {
                    if (!err) {
                        delete context.session;
                        delete context.socket_session;
                        self[Listener].emit('token-refreshed', context, token);
                    }
                });
            }
            return process.nextTick(() => {
                self[Listener].emit('token-refreshed', context, token);
            });
        }
    }

    /**
     * 2. refresh-token 已过期
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenRefreshExpired (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-refresh-expired', context, data);
    }

    /**
     * 3. token 不存在
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenRemoved (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-not-exist', context, data);
    }

    /**
     * 4. token 已被踢出
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenKicked (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-was-kicked', context, data);
    }

    /**
     * 5. token 已被 sso 踢出
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenSsoOut (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-was-kicked-by-sso', context, data);
    }

    /**
     * 6. token 已被 manager 踢出
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenKickedByManager (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        // 在未监听 token-was-kicked-by-manager 时，将使用 token-not-exist 抛出（这是一个兼容处理，因为原来就是将这个 token-not-exist 当成是管理员踢出的处理）
        if (this[Listener].listenerCount('token-was-kicked-by-manager')) {
            this[Listener].emit('token-was-kicked-by-manager', context, data);
        } else {
            this[Listener].emit('token-not-exist', context, data);
        }
    }

    /**
     * 7. 其它需要强制踢用户下线的ErrorCode
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenForceOut (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-force-out', context, data);
    }

    /**
     * 8. token 过期（ 当前应用无法处理时，才会抛出此事件，一般为无 refresh_token 时 ）
     * @param context {object}
     * @param data {object | undefined}
     */
    fireTokenExpired (context, data) {
        if (!Util.check(context)) { return; }
        delete context.session;
        delete context.socket_session;
        this[Listener].emit('token-expired', context, data);
    }
}

/**
 * 实例对外可抛出的事件：
 * 1. token-refreshed               // function(context, token) {}
 * 2. token-refresh-expired         // function(context, data) {}
 * 3. token-not-exist               // function(context, data) {}
 * 4. token-was-kicked              // function(context, data) {}
 * 5. token-was-kicked-by-sso       // function(context, data) {}
 * 6. token-was-kicked-by-manager   // function(context, data) {}
 * 7. token-force-out               // function(context, data) {}
 * 8. token-expired                 // function(context, data) {}
 *
 * @type {TokenEvent}
 */
module.exports = new TokenEvent();
