/*!
 * Copyright (c) 2010-2019 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2019 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * index.js
 * Created by wuyaoqian on 2019/1/10.
 */

const DataSdkRest = require("data-sdk-rest");
const BackOff = require('backo2');
const path = require('path');
const log4js = require('log4js-config');

const logger = log4js.get('eefung.apollo-client-sdk.' + path.basename(__filename));

class ApolloClient {

    /**
     * 初始化SDK（ config.notify 存在的话，则会自动检测配置数据的更新）
     * @param {object} config
     * @param {array|string} config.serverUrl
     * @param {string} config.appId
     * @param {string} [config.clusterName=default]
     * @param {string} config.namespace
     * @param {boolean} [config.token=false]
     * @param {object} [config.backOff=null]
     * @param {object} [config.backOff[check|fetch]=null]
     * @param {number} [config.backOff[check|fetch].min]
     * @param {number} [config.backOff[check|fetch].max]
     * @param {number} [config.backOff[check|fetch].factor]
     * @param {number} [config.backOff[check|fetch].jitter]
     * @param {function} [notify=null]
     */
    constructor (config, notify) {
        this.urls = Array.isArray(config.serverUrl) ? config.serverUrl : [config.serverUrl];
        this.appid = config.appId || config.appid;
        this.cluster = config.clusterName || config.cluster || 'default';
        this.namespace = config.namespace;
        this.mode = config.token ? 'appTokenRestler' : 'baseRestler';
        this.notify = typeof notify === 'function' ? notify : null;
        this.backOff = config.backOff || {};

        this._data = null;
        this._latestNotifyId = -1;
        this._cluster_process_promise = {};
        this._fetchPromise = null;

        // 获取数据的周期（失败时）
        this.backOff.fetch = this.backOff.fetch || {};
        this._bo_fetch = new BackOff({
            min: this.backOff.fetch.min || 1000 * 5,
            max: this.backOff.fetch.max || 1000 * 60,
            factor: this.backOff.fetch.factor || 1.5,
            jitter: this.backOff.fetch.jitter || 0
        });

        if (this.notify) {
            // 更新检测的周期（失败时）
            this.backOff.check = this.backOff.check || {};
            this._bo_check = new BackOff({
                min: this.backOff.check.min || 1000 * 10,
                max: this.backOff.check.max || 1000 * 60 * 2,
                factor: this.backOff.check.factor || 1.5,
                jitter: this.backOff.check.jitter || 0
            });
            // 开始更新检测
            this._check_process_();
        }
    }

    /**
     * 请求获取最新的配置数据
     * @param {string} host
     * @return {Promise<*>}
     * @private
     */
    _request_latest_ (host) {
        let self = this;
        let url = `${host}/configs/${this.appid}/${this.cluster}/${this.namespace}`;
        return new Promise((resolve, reject) => {
            DataSdkRest[this.mode].get(url).on('error', function (error) {
                logger.error('fetch latest config from %s has error', host, (error && error.stack ? error.stack : error));
                reject(error);
            }).on('fail', function (error) {
                logger.error('fetch latest config from %s was failed', host, (error && error.stack ? error.stack : error));
                reject(error);
            }).on('success', function (data) {
                let content = data;
                if (self.namespace.endsWith('.json')) {
                    try { content = JSON.parse(data.configurations.content); } catch (error) {
                        logger.error('fetch latest config received malformed json content: ', (error && error.stack ? error.stack : error));
                    }
                }
                resolve(content);
            });
        });
    }

    /**
     * 检测配置的更新
     * @param {string} host
     * @param {int} nid
     * @return {Promise<*>}
     * @private
     */
    _check_update_ (host, nid) {
        let self = this;
        let url = `${host}/notifications/v2?appId=${this.appid}&cluster=${this.cluster}&notifications=${encodeURIComponent(JSON.stringify([{
            "namespaceName": this.namespace,
            "notificationId": nid || -1
        }]))}`;
        return new Promise((resolve, reject) => {
            DataSdkRest[this.mode].get(url, {
                timeout: 1000 * 60 * 2,
                logMinTime: (1000 * 60) + (1000 * 10)
            }).on('error', function (error) {
                logger.error('check config update from %s has error', host, (error && error.stack ? error.stack : error));
                reject(error);
            }).on('fail', function (error) {
                logger.error('check config update from %s was failed', host, (error && error.stack ? error.stack : error));
                reject(error);
            }).on('success', function (data, response) {
                if (response.statusCode.toString() === '304') {
                    resolve(self._latestNotifyId);
                } else {
                    resolve(data[0].notificationId);
                }
            });
        });
    }

    /**
     * 根据 urls 自动选择其中的一个或多个 host 请求服务器，成功后将智能更新 urls 内排序
     * @param {string} method
     * @param {*} [param]
     * @return {*|Promise<*>}
     * @private
     */
    _cluster_process_ (method, param) {
        let ret = null;
        let process = function (len, index, resolve, reject) {
            this[method](this.urls[index], param).then((data) => {
                delete this._cluster_process_promise[method];
                // 将可以正常响应的 host 与第一位交换位置，方便下次直接使用这个 host 请求数据
                if (index !== 0) {
                    let host = this.urls[0];
                    this.urls[0] = this.urls[index];
                    this.urls[index] = host;
                }
                !ret && resolve(ret = data);
            }, (error) => {
                if (ret || (index === len - 1)) {
                    // （已有正常响应）||（已全部请求完毕，但都是错误响应）=> 则这时候直接返回错误结果
                    delete this._cluster_process_promise[method];
                    reject(error);
                } else {
                    // 其它情况，进入下一个 host 的请求
                    process.call(this, len, index + 1, resolve, reject)
                }
            });
        };
        return this._cluster_process_promise[method] || (this._cluster_process_promise[method] = new Promise((resolve, reject) => {
            process.call(this, this.urls.length, 0, resolve, reject);
        }));
    }

    /**
     * 处理 update-check, 如果失败，则会周期的进行重试逻辑
     * @private
     */
    _check_process_ () {
        let self = this;
        self._cluster_process_('_check_update_', this._latestNotifyId).then((nid) => {
            self._bo_check.reset();
            if (self._latestNotifyId === nid) {
                return self._check_process_();
            }
            self.fetch(true).then((data) => {
                logger.info('latest config (appid: %s, namespace: %s) data loaded or updated.', self.appid, self.namespace);
                self._data = data;
                self._latestNotifyId = nid;
                self.notify(data);
                self._check_process_();
            });
        }, () => {
            let time = self._bo_check.duration();
            logger.warn('all update check was failed, continue trying on next %ss.', time / 1000);
            setTimeout(() => {
                self._check_process_();
            }, time);
        });
    }

    /**
     * 处理 latest-config-fetch, 如果失败，则会周期的进行重试逻辑
     * @param resolve
     * @private
     */
    _fetch_process_ (resolve) {
        let self = this;
        self._cluster_process_('_request_latest_').then(function (data) {
            self._bo_fetch.reset();
            resolve(data);
            delete self._fetchPromise;
        }, () => {
            let time = self._bo_fetch.duration();
            logger.warn('all config fetch was failed, continue trying on next %ss.', time / 1000);
            setTimeout(() => {
                self._fetch_process_(resolve);
            }, time);
        });
    }

    /**
     * 获取配置数据
     * @param {boolean} remote
     * @return {*}
     */
    fetch (remote) {
        // 1. 如果本地缓存中有数据，则直接返回
        if (this._data && !remote) { return Promise.resolve(this._data); }

        // 2. 本地没有缓存数据，直接远程请求数据
        let self = this;
        return this._fetchPromise || (this._fetchPromise = new Promise(function (resolve) {
            self._fetch_process_(resolve);
        }));
    }

}

module.exports = ApolloClient;