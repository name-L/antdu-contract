/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

"use strict";

/**
 * caster client map store
 * Created by wuyaoqian on 2016/11/23.
 */

var path = require("path");
var EventEmitter = require("events").EventEmitter;
var CasterClient = require("./caster-client.js");
var logger = require("log4js-config").get("eefung.webapp.caster-store." + path.basename(__filename));
var config = require("config").system;
var timeElapseLogger = require("log4js-config").get("eefung.webapp.caster-store.time-elapse." + path.basename(__filename));
var elapseLogMinTime = Number.isFinite(config.elapseLogMinTime) ? config.elapseLogMinTime : 0;
var sdkRestTimeout = Number.isFinite(config.sdkRestTimeout) ? config.sdkRestTimeout : 1000 * 60;

var instances = {};

/**
 * caster store
 * @param name
 * @param defaultExpirationTime
 * @constructor
 */
var CasterMap = function (name, defaultExpirationTime) {
    var self = this;
    self.listeners = [];
    self.defaultExpirationTime = defaultExpirationTime || 10 * 60 * 1000;
    self.mapName = name;
    self.rawClient = null;
    self.rawMap = null;

    CasterClient.getInstance().then(function (instance) {
        self.rawClient = instance.rawClient;
        self.rawMap = self.rawClient.getMap(self.mapName);
        instance.on('reconnect', function (rawClient) {
            var oldListeners = self.listeners, oldRawMap = self.rawMap;
            self.rawClient = rawClient;
            self.rawMap = rawClient.getMap(self.mapName);
            self.listeners = [];
            oldListeners.forEach(function (obj) {
                oldRawMap.removeEntryListener(obj.id).then(function () {
                    self.addEntryListener(obj.listener, obj.key, obj.includeValue);
                });
            });
        });
        self.emit('connected', self);
    });
};
CasterMap.prototype = Object.create(EventEmitter.prototype);

/**
 * add map entry listener
 * @param listener {object<string, function>}
 * @param key {string|undefined}
 * @param includeValue {boolean|undefined}
 * @return {Promise}
 */
CasterMap.prototype.addEntryListener = function (listener, key, includeValue) {
    var self = this;
    if (!self.rawMap) {
        logger.error("addEntryListener has error: ", "caster map not init");
        return Promise.reject();
    }
    return self.rawMap.addEntryListener(listener, key, includeValue).then(function (id) {
        self.listeners.push({
            id: id,
            listener: listener,
            key: key,
            includeValue: includeValue
        });
    });
};

/**
 * 从 CasterStore 中获取数据
 * @param key {string|array} 数据的唯一key
 * @param fn {function} 回调函数 function(error, data) {}
 * @returns {*}
 */
CasterMap.prototype.get = function (key, fn) {
    var startTime = Date.now(), elapseTime, method = 'get', timeid, isTimeOut = false;
    if (!this.rawMap) {
        return fn && fn('caster map not init');
    }
    if (key === undefined) { key = ''; }
    if (Array.isArray(key)) {
        key = key.map(function (k) { return k || ''; });
        method = 'getAll';
    }

    // 兼容应用中未依赖 @component-util/cls-support 的应用
    var cls, oldFn, oldStore;
    try { cls = require.resolve('@component-util/cls-support') } catch (e) {}
    if (cls) {
        cls = require(cls);
        oldFn = fn;
        oldStore = cls.getAll();
        fn = function (error, data) {
            if (oldStore && !cls.getAll()) {
                cls.init(function () {
                    cls.setAll(oldStore);
                    oldFn(error, data);
                });
            } else {
                oldFn(error, data);
            }
        };
    }

    // 设定超时机制
    timeid = setTimeout(function () {
        isTimeOut = true;
        logger.error(`fetch caster-map data (key: ${key}) timeout: ${sdkRestTimeout / 1000}s`);
        return fn && fn(new Error(`caster-map timeout: ${sdkRestTimeout}, type: fetch`));
    }, sdkRestTimeout);

    this.rawMap[method](key).then(function (data) {
        clearTimeout(timeid);
        if (timeElapseLogger.isLevelEnabled("info")) {
            elapseTime = Date.now() - startTime;
            if (elapseTime > elapseLogMinTime) {
                timeElapseLogger[isTimeOut ? 'warn' : 'info']("fetch caster-map data (key: %s, isTimeOut: %s) taking %ss", key, isTimeOut, elapseTime / 1000);
            }
        }
        if (isTimeOut) { return; }
        if (method === 'getAll') {
            return fn && fn(null, key.map(function (k) {
                var value = data.find(function (v) {
                    return (Array.isArray(v) && v.length === 2 && k === v[0]);
                });
                return value && value[1];
            }));
        }
        return fn && fn(null, data);
    }, function (error) {
        clearTimeout(timeid);
        logger.error("fetch caster-map data (key: %s, isTimeOut: %s) has error: ", key, isTimeOut, (error && error.stack) ? error.stack : error);
        if (isTimeOut) { return; }
        return fn && fn(error);
    }).catch(function (error) {
        logger.error("fetch caster-map data (key: %s) has error when execute callback function, detail: ", key, (error && error.stack) ? error.stack : error);
    });
};

/**
 * 往 CasterStore 中写入数据
 * @param key {string} 数据的唯一key
 * @param data {*} 待写入的数据
 * @param fn {function} 回调函数 function(error, data) {}
 * @param ttl {int} 数据的有效时间(超过此时间, 将自动删除)
 * @returns {*}
 */
CasterMap.prototype.put = function (key, data, fn, ttl) {
    var startTime = Date.now(), elapseTime, timeid, isTimeOut = false;
    if (!this.rawMap) {
        return fn && fn('caster map not init');
    }
    if (key === undefined) { key = ''; }
    if (data === undefined) { data = ''; }

    // 设定超时机制
    timeid = setTimeout(function () {
        isTimeOut = true;
        logger.error(`update caster-map data (key: ${key}) timeout: ${sdkRestTimeout / 1000}s`);
        return fn && fn(new Error(`caster-map timeout: ${sdkRestTimeout}, type: update`));
    }, sdkRestTimeout);

    this.rawMap.put(key, data, ttl || this.defaultExpirationTime).then(function () {
        clearTimeout(timeid);
        if (timeElapseLogger.isLevelEnabled("info")) {
            elapseTime = Date.now() - startTime;
            if (elapseTime > elapseLogMinTime) {
                timeElapseLogger[isTimeOut ? 'warn' : 'info']("update caster-map data (key: %s, isTimeOut: %s) taking %ss", key, isTimeOut, elapseTime / 1000);
            }
        }
        if (isTimeOut) { return; }
        return fn && fn(null, true);
    }, function (error) {
        clearTimeout(timeid);
        logger.error("update caster-map data (key: %s, isTimeOut: %s) has error: ", key, isTimeOut, (error && error.stack) ? error.stack : error);
        if (isTimeOut) { return; }
        return fn && fn(error);
    }).catch(function (error) {
        logger.error("update caster-map data (key: %s) has error when execute callback function, detail: ", key, (error && error.stack) ? error.stack : error);
    });
};

/**
 * 从 CasterStore 中删除数据
 * @param key {string} 数据的唯一key
 * @param fn {function} 回调函数 function(error, data) {}
 * @returns {*}
 */
CasterMap.prototype.del = function (key, fn) {
    var startTime = Date.now(), elapseTime, timeid, isTimeOut = false;
    if (!this.rawMap) {
        return fn && fn('caster map not init');
    }
    if (key === undefined) { key = ''; }

    // 设定超时机制
    timeid = setTimeout(function () {
        isTimeOut = true;
        logger.error(`remove caster-map data (key: ${key}) timeout: ${sdkRestTimeout / 1000}s`);
        return fn && fn(new Error(`caster-map timeout: ${sdkRestTimeout}, type: remove`));
    }, sdkRestTimeout);

    this.rawMap.remove(key).then(function () {
        clearTimeout(timeid);
        if (timeElapseLogger.isLevelEnabled("info")) {
            elapseTime = Date.now() - startTime;
            if (elapseTime > elapseLogMinTime) {
                timeElapseLogger[isTimeOut ? 'warn' : 'info']("remove caster-map data (key: %s, isTimeOut: %s) taking %ss", key, isTimeOut, elapseTime / 1000);
            }
        }
        if (isTimeOut) { return; }
        return fn && fn(null, true);
    }, function (error) {
        clearTimeout(timeid);
        logger.error("remove caster-map data (key: %s, isTimeOut: %s) has error: ", key, isTimeOut, (error && error.stack) ? error.stack : error);
        if (isTimeOut) { return; }
        return fn && fn(error);
    }).catch(function (error) {
        logger.error("remove caster-map data (key: %s) has error when execute callback function, detail: ", key, (error && error.stack) ? error.stack : error);
    });
};

module.exports = {
    /**
     * 获取 caster 指定的 map
     * @param mapName {string} map名称
     * @param defaultExpirationTime {int} 默认过期时间
     * @return {Promise} {
     *      resolve: function(instance){}
     * }
     */
    getInstance: function (mapName, defaultExpirationTime) {
        return new Promise(function (resolve) {
            var instance = instances[mapName];
            if (!instance) {
                instance = instances[mapName] = new CasterMap(mapName, defaultExpirationTime);
            }
            if (instance.rawMap) {
                process.nextTick(function () {
                    resolve(instance);
                });
            } else {
                instance.on('connected', function () {
                    resolve(instance);
                });
            }
        });
    }
};