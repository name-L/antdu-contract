/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

"use strict";

/**
 * 一些重载方法
 * Created by wuyaoqian on 2017/2/23.
 */

const EventEmitter = require("events");
const HazelcastClientIndex = require("hazelcast-client");
const Address = HazelcastClientIndex.Address;

const emitter = new EventEmitter();

// 覆盖 onConnectionClosed, onHeartbeatStopped 方法，因为 ownerConnection 有可能为 null；   ----  2017-2-23 v0.6.0
(function overwriteClusterServicePrototype () {
    const ClusterService = require("hazelcast-client/lib/invocation/ClusterService.js");
    const LifecycleService = require("hazelcast-client/lib/LifecycleService.js");
    const BackOff = require('backo2');
    const retryBackOff = new BackOff({
        min: 1000,
        max: 1000 * 60,
        factor: 1.5,
        jitter: 0
    }), retryFn = function (service, address) {
        var timeoutid = 0, pending = true, connectTimeoutCheckMinTime = 1000 * 30, checkTime;
        if (retryFn.retryFromAddr) {
            service.logger.warn('ClusterService', 'already trying connect to cluster, preFromAddress:' + retryFn.retryFromAddr + ', currFromAddress:' + address + '');
            return;
        }
        retryFn.retryFromAddr = address;
        service.logger.info('ClusterService', 'Trying (' + (retryBackOff.attempts + 1) + ') connect to cluster after ownerConnection ' + address + ' was set null ');
        service.connectToCluster().then(function () {
            if (!pending || !retryFn.retryFromAddr) {
                return;
            }
            service.logger.info('ClusterService', 'Reconnect success (retryFromAddress:' + address + ').');
            retryBackOff.reset();
            clearTimeout(timeoutid);
            pending = false;
            delete retryFn.retryFromAddr;
            service.client.heartbeat.cancel();
            service.client.heartbeat.start();
            service.client.lifecycleService.emitLifecycleEvent(LifecycleService.LifecycleEvent.started);
            emitter.emit('reconnect', service.client);
        }).catch(function (reason) {
            if (!pending || !retryFn.retryFromAddr) {
                return;
            }
            service.logger.warn('ClusterService', 'Trying connect to cluster failed, then try shutdown', reason);
            clearTimeout(timeoutid);
            pending = false;
            service.client.shutdown();
            service.client.connectionManager.pendingConnections = {};
            service.client.connectionManager.establishedConnections = {};
            setTimeout(function () {
                delete retryFn.retryFromAddr;
                retryFn(service, address);
            }, retryBackOff.duration());
        });
        // 设置一个最小30秒的超时连接时间 v0.6.1: 2017-10-13
        // 注意：在 service.connectToCluster 时，有可能会被卡住的情况出现，具体的可能原因如下:
        // 1>. socket.error 事件，有可能会延迟抛出；
        clearTimeout(timeoutid);
        checkTime = Math.max(connectTimeoutCheckMinTime, retryBackOff.duration());
        timeoutid = setTimeout(function () {
            if (!pending || !retryFn.retryFromAddr) {
                return;
            }
            service.logger.warn('ClusterService', 'Trying connect to cluster timeout ( ' + (checkTime / 1000) + 's ), then try shutdown');
            pending = false;
            service.client.shutdown();
            service.client.connectionManager.pendingConnections = {};
            service.client.connectionManager.establishedConnections = {};
            delete retryFn.retryFromAddr;
            retryFn(service, address);
        }, checkTime);
    };

    // 1. onConnectionClosed
    ClusterService.prototype.onConnectionClosed = function (connection) {
        this.logger.warn('ClusterService', 'Connection closed to ' + Address.encodeToString(connection.address) + ', current ownerConnection is ' + (this.ownerConnection ? Address.encodeToString(this.ownerConnection.address) : 'null'));
        if (this.ownerConnection && connection.address === this.ownerConnection.address) {
            this.ownerConnection = null;
        }
        if (!this.ownerConnection) {
            retryFn(this, Address.encodeToString(connection.address));
            // this.logger.info('ClusterService', 'Trying connect to cluster after ownerConnection (' + Address.encodeToString(connection.address) + ') was set null ');
            // this.connectToCluster().catch(this.client.shutdown.bind(this.client));
        }
    };

    // 2. onHeartbeatStopped
    ClusterService.prototype.onHeartbeatStopped = function (connection) {
        this.logger.warn('ClusterService', Address.encodeToString(connection.address) + ' stopped heartbeating.');
        this.client.getConnectionManager().destroyConnection(connection.address);
    };

})();

// 覆盖 connect 方法，在 socket.write 的回调后，才执行 ready.resolve  ----  2017-7-17 v0.6.0
(function overwriteClientConnectionPrototype () {
    const Promise = require('bluebird');
    const net = require('net');
    const tls = require('tls');
    const ClientConnection = require("hazelcast-client/lib/invocation/ClientConnection.js");

    // 1. connect
    ClientConnection.prototype.connect = function () {
        var _this = this;
        var ready = Promise.defer();
        var conCallback = function () {
            var buffer = new Buffer(3);
            buffer.write('CB2');
            _this.socket.write(buffer, function (e) {
                if (!e) {
                    // 2.5秒后，执行回调（因为 socket.error 事件，有可能会延迟抛出 2017-07-19）
                    // 这里注释是因为 socket.error 事件被触发的时间不确定，所以没法在这里设定一个具体的延迟时间（2020-2-25）
                    // setTimeout(function () {
                    //     ready.resolve(_this);
                    // }, 1000 * 2.5);
                    ready.resolve(_this);
                } else {
                    ready.reject(e);
                }
            });
        };
        if (this.clientNetworkConfig.sslOptions) {
            var sslSocket = tls.connect(this.address.port, this.address.host, this.clientNetworkConfig.sslOptions, conCallback);
            this.localAddress = new Address(sslSocket.address.address, sslSocket.address.port);
            this.socket = sslSocket;
        } else {
            var netSocket = net.connect(this.address.port, this.address.host, conCallback);
            this.localAddress = new Address(netSocket.localAddress, netSocket.localPort);
            this.socket = netSocket;
        }
        this.socket.on('error', function (e) {
            _this.logging.warn('ClientConnection', 'Could not connect to address ' + Address.encodeToString(_this.address), e);
            ready.reject(e);
        });
        return ready.promise;
    }

})();

// 覆盖 getOrConnect 方法，设定一个连接超时未响应的机制  ----  2020-2-25 v0.6.0
(function overwriteClientConnectionManagerPrototype () {
    const Promise = require('bluebird');
    const ClientConnectionManager = require("hazelcast-client/lib/invocation/ClientConnectionManager.js");

    // 1. getOrConnect
    const oldGetOrConnect = ClientConnectionManager.prototype.getOrConnect;
    ClientConnectionManager.prototype.getOrConnect = function (address, ownerConnection) {
        var _this = this;
        var ready = Promise.defer();
        var timeoutId, delay = 1000 * 30;
        oldGetOrConnect.call(this, address, ownerConnection).then(function (connection) {
            clearTimeout(timeoutId);
            ready.resolve(connection);
        }).catch(function (error) {
            clearTimeout(timeoutId);
            ready.reject(error);
        });
        timeoutId = setTimeout(function () {
            ready.reject(new Error('ClientConnectionManager getOrConnect no response in ' + (delay / 1000) + ' second'));
            var addressIndex = Address.encodeToString(address);
            if (_this.pendingConnections[addressIndex]) {
                delete _this.pendingConnections[addressIndex];
            }
        }, delay);
        return ready.promise;
    }

})();

// 覆盖 sendToAddress 方法，捕获异常  ----  2020-6-16 v0.6.0
(function overwriteInvocationServicePrototype () {
    const ISExports = require("hazelcast-client/lib/invocation/InvocationService.js");

    // 1. sendToAddress
    const oldSendToAddress = ISExports.InvocationService.prototype.sendToAddress;
    ISExports.InvocationService.prototype.sendToAddress = function (invocation, address) {
        var logger = this.logger;
        var retPromise = oldSendToAddress.call(this, invocation, address);
        retPromise.catch(function (error) {
            logger.error('InvocationService', 'sendToAddress was error', error);
        });
        return retPromise;
    };

})();
module.exports = emitter;
