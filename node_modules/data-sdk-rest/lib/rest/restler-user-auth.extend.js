/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 在 restler-base.extend.js 的基础上再次扩展 restler 使其自动加入 Token 等想关代码
 * Created by wuyaoqian on 13-11-18.
 */

const path = require('path');
const baseRestler = require('./restler-base.extend.js');
const authRestler = Object.assign({}, baseRestler);
const tokenProvider = require('../token/token-provider.js');
const logger = require('log4js-config').get('eefung.data-sdk-rest.' + path.basename(__filename));
const userDataManage = require('../user/user-data.store.js');

/**
 * Restler 的一些相关扩展
 */
const RestlerExtend = {
    /**
     * 请求前的一个处理 (start)
     * @param context {object}
     * @param opt {object} {
     *      user: {userid, username},      // 用户的一些基本信息
     *      token: {}                      // 用户的token信息
     * }
     *
     * @returns {object} instance
     */
    prepareRequestStart: function (context, opt) {
        const instance = this;
        const user = opt.user || {};

        // 为每一次请求记录一个ID
        context.id = Date.now() + '-' + parseInt(Math.random() * 10000);

        user.userid = user.userid || '-';
        user.username = user.username || '-';
        opt.user = user;

        // 无效token，直接返回。
        if (!opt.token || !opt.token.access_token) {
            logger.debug('No UserAccessToken Found In Session, Try Next Time.');
            instance.abort();
            instance._fireCancelTimeout();
            process.nextTick(function () {
                const errorCodeDesc = {
                    'errorCode': '00116',
                    'httpStatusCode': 500,
                    'description': '请求体中没有带token',
                    'type': '公共基础异常'
                };
                const customResponse = {
                    statusCode: 500,
                    raw: '这是SDK主动抛出的自定义异常信息(UserTokenRequest)'
                };
                instance.emit('error', errorCodeDesc, customResponse);
                instance.emit('complete', errorCodeDesc, customResponse);
            });
            return instance;
        }

        // 如果当前是正在刷新token，则延迟发送请求
        const delayRequest = instance.initDelayRequestHandle();
        tokenProvider.validateToken(opt.token).then((token) => {
            opt.token = token;
            delayRequest(RestlerExtend.prepareRequestEnd.call(instance, context, opt));
        }).catch((result) => {
            instance.abort();
            instance._fireCancelTimeout();
            if (!result || result instanceof Error || !result.type || !result.response) {
                const customResponse = {
                    statusCode: 500,
                    raw: '这是SDK主动抛出的自定义异常信息(UserTokenRequest: ValidateToken Catch Error)'
                };
                instance.emit('error', result, customResponse);
                instance.emit('complete', result, customResponse);
            } else if (result.type === 'refresh-error') {
                instance.emit('fail', result.error, result.response);
                instance.emit('complete', result.error, result.response);
            }
        });

        return instance;
    },
    /**
     * 请求前的一个处理 (end)
     * @param context {object}
     * @param opt {object}
     * @returns {object} instance
     */
    prepareRequestEnd: function (context, opt) {
        const instance = this;

        // 1. 将 accessToken 放入请求头中（1. option: 方便下次的retry， 2. setHeader: 直接在替换当前的请求head参数）
        instance.options.headers['authorization'] = 'oauth2 ' + opt.token.access_token;
        instance.request.setHeader('authorization', 'oauth2 ' + opt.token.access_token);

        // 2. 定义授权出错的拦截
        const oauthProxyFail = function (errorObj, response) {
            const errorCodeNumber = (errorObj && typeof errorObj === 'object')
                ? parseInt(errorObj['error_code'] || errorObj['errorCode'])
                : false;
            if (!errorCodeNumber || !tokenProvider.isGlobalUserTokenError(errorCodeNumber)) {
                return;
            }
            logger.warn(
                'receive auth-error(rest), username: %s, code: %s, id: %s, \nurl: %s',
                opt.user.username || '-', errorCodeNumber, context.id, instance.url.href
            );
            instance['_process_token_validate_'] = true;
            context.res_data_server = response;
            tokenProvider.processUserTokenError(errorCodeNumber, {
                token: opt.token,
                user: opt.user
            }, context).on('token-refresh-successful', function (newToken) {
                delete instance['_process_token_validate_'];
                instance.options.headers['authorization'] = 'oauth2 ' + newToken.access_token;
                instance.retry();
            }).on('token-refresh-error', function (err, resp) {
                delete instance['_process_token_validate_'];
                instance.emit('fail', err, resp);
            }).on('token-already-logout', function () {
                delete instance['_process_token_validate_'];
                instance.emit('fail', errorObj, response);
            });
        };

        // 3. 代理 complete, fail, 400, 4XX 方法，以方便对授权出错的拦截
        (function () {
            let instance = this;
            let originalComplete = instance.listeners('complete');
            let originalFail = instance.listeners('fail');
            let original400 = instance.listeners('400');
            let original4XX = instance.listeners('4XX');
            let proxyHandler = function (handlers) {
                if (!this['_process_token_validate_']) {
                    for (let i = 0; i < handlers.length; i++) {
                        handlers[i].apply(this, Array.prototype.slice.apply(arguments, [1]));
                    }
                }
            };
            instance._events['fail'] = [oauthProxyFail, proxyHandler.bind(instance, originalFail)];
            instance._events['complete'] = proxyHandler.bind(instance, originalComplete);
            instance._events['400'] = proxyHandler.bind(instance, original400);
            instance._events['4XX'] = proxyHandler.bind(instance, original4XX);
        }).call(instance);

        return instance;
    }
};

/**
 * 从 Restler 内抽取出来的，并有所改动
 */
const RestlerOverride = {
    baseRequest: function (method, url, options) {
        let context = {
            req: options.req,
            res: options.res
        };
        return RestlerExtend.prepareRequestStart.call(baseRestler[method](url, options), context, {
            user: userDataManage.session.userInfo.get(context.req.session),
            token: userDataManage.session.userToken.get(context.req.session)
        });
    }
};

// 重载 get、patch、post、put、del、head 方法
authRestler.get = RestlerOverride.baseRequest.bind(RestlerOverride, 'get');
authRestler.patch = RestlerOverride.baseRequest.bind(RestlerOverride, 'patch');
authRestler.post = RestlerOverride.baseRequest.bind(RestlerOverride, 'post');
authRestler.put = RestlerOverride.baseRequest.bind(RestlerOverride, 'put');
authRestler.del = authRestler.delete = RestlerOverride.baseRequest.bind(RestlerOverride, 'delete');
authRestler.head = RestlerOverride.baseRequest.bind(RestlerOverride, 'head');

// 暴露 RestlerExtend.prepareRequest
authRestler[Symbol.for('UserAuthPrepareRequest')] = RestlerExtend.prepareRequestStart;

/**
 * 重新包装好后，再次Exports出去
 * 属性：
 * 1. events             // EventEmitter 实例
 * 2. prepareRequest     // RestlerExtend.prepareRequest
 *
 * 方法：
 * 1. get
 * 2. patch
 * 3. post
 * 4. put
 * 5. del
 * 6. head
 */
module.exports = authRestler;
