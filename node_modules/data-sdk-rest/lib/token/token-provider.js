/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * Created by wuyaoqian on 13-11-17. <br />
 * 提供：与Token有关的相关方法
 */

const AccessToken = require('./access-token');
const EventEmitter = require('events');
const tokenEvent = require('./token-event');
const path = require('path');
const restler = require('../rest/restler-base.extend.js');
const config = require('config').oauth;
const logger = require('log4js-config').get('eefung.data-sdk-rest.' + path.basename(__filename));

// 授权方式
const GRANT_TYPE = {
    PASSWORD: 'password', // 密码方式
    CLIENT_CREDENTIALS: 'client_credentials', // 应用ID方法
    REFRESH_TOKEN: 'refresh_token', // 刷新token
    AUTHORIZATION_CODE: 'authorization_code' // ...
};

// 内部方法或属性
const RequestApplicationAccessToken = Symbol('RequestApplicationAccessToken');
const RefreshUserAccessToken = Symbol('RefreshUserAccessToken');
const Progress = Symbol('Progress');
const ForceUserOutErrorCodes = Symbol('ForceUserOutErrorCodes');

/**
 * 与Token有关的相关方法与属性
 * @constructor
 */
class TokenProvider {
    constructor () {
        this.appToken = null;
        this[Progress] = {
            'appTokenFetchMaxTime': 1000 * 60 * 2, // 2 分钟还未返回 appToken，则执行 promise.reject() 方法
            'appTokenRequestStrategy': {
                requestPromise: null, // 获取 appToken 的 promise 对象
                retryDelayTimeInterval: 1000, // 下次重试的延迟时间的增长间隔
                currentRetryDelayTime: 0, // 下次重试的延迟时间
                retryDelayMaxTime: 1000 * 60, // 下次重试的延迟时间的最大值(即: 下次重试的时间不得超过这个值)
                inFetchingAppToken: false // 当前是否正在远程获取appToken当中
            },
            'refreshTokenPromise': {}
        };
        this[ForceUserOutErrorCodes] = {};
        if (Array.isArray(config.forceUserOutErrorCodes) && config.forceUserOutErrorCodes.length) {
            config.forceUserOutErrorCodes.forEach((code) => {
                this[ForceUserOutErrorCodes]['' + parseInt(code)] = true;
            });
        }
    }

    /**
     * -1. 远程请求 Application Access Token；
     * @private
     * @return {Promise} {
     *      resolve: function(appToken) {}
     * }
     */
    [RequestApplicationAccessToken] () {
        const self = this;
        const strategy = self[Progress]['appTokenRequestStrategy'];
        if (strategy.requestPromise) {
            return strategy.requestPromise;
        }

        return (strategy.requestPromise = new Promise(function (resolve) {
            // 远程获取 token （有错误时，继续尝试获取，直到成功为止）
            function handler () {
                logger.debug('start request application access Token.');
                restler.post(config.tokenServerUrl, {
                    data: {
                        'client_id': config.appKey,
                        'client_secret': config.appSecret,
                        'grant_type': GRANT_TYPE.CLIENT_CREDENTIALS
                    }
                }).on('error', function (error, response) {
                    strategy.currentRetryDelayTime = Math.min(
                        strategy.currentRetryDelayTime + strategy.retryDelayTimeInterval,
                        strategy.retryDelayMaxTime
                    );
                    logger.error(
                        'application token request has error, httpCode: %s, next retry time: %ss, detail:\n',
                        (response && response.statusCode) ? response.statusCode : 'null',
                        (strategy.currentRetryDelayTime / 1000),
                        (error && error.stack ? error.stack : error)
                    );
                    setTimeout(handler, strategy.currentRetryDelayTime);
                }).on('fail', function (error, response) {
                    strategy.currentRetryDelayTime = Math.min(
                        strategy.currentRetryDelayTime + strategy.retryDelayTimeInterval,
                        strategy.retryDelayMaxTime
                    );
                    logger.error(
                        'application token request was failed, httpCode: %s, next retry time: %ss, detail:\n',
                        (response && response.statusCode) ? response.statusCode : 'null',
                        (strategy.currentRetryDelayTime / 1000),
                        (error && error.stack ? error.stack : error)
                    );
                    setTimeout(handler, strategy.currentRetryDelayTime);
                }).on('success', function (result) {
                    delete strategy.requestPromise;
                    self.appToken = new AccessToken(result.access_token, result.expires_in, result.refresh_token);
                    logger.info(
                        'success fetched appToken (A: %s, R: %s, E: %s)',
                        self.appToken.access_token, self.appToken.refresh_token, self.appToken.expires_in
                    );
                    resolve(self.appToken);
                });
            }

            // 使用 nextTick 后， handler 内发生任意运行时异常，都将不会调用 resolve 或 reject 方法, 而是出现 uncatchedException
            process.nextTick(handler);
        }));
    }

    /**
     * -2. 刷新 user token
     * @param token {AccessToken}
     * @param user {object}
     * @param context {object}
     * @return {Promise} {
     *      resolve: function(token) {}
     *      reject: function({error, response}) {}
     * }
     */
    [RefreshUserAccessToken] (token, user, context) {
        const self = this;
        const strategy = self[Progress]['refreshTokenPromise'];
        if (strategy[token.refresh_token]) {
            return strategy[token.refresh_token];
        }

        // 会自动的忽略 同一个 refreshToken 刷新后的请求
        const delayAutoDelete = function (immediately) {
            if (immediately) {
                delete strategy[token.refresh_token];
            } else {
                setTimeout(() => {
                    delete strategy[token.refresh_token];
                }, 1000 * 10);
            }
        };

        // 拦截错误处理
        const errorHandler = function (type, error, response, reject, resolve) {
            const data = {
                type: '',
                error,
                response,
                code: (error && typeof error === 'object')
                    ? parseInt(error['error_code'] || error['errorCode'])
                    : false
            };
            const tokenEventData = {
                errorType: 'refresh-error',
                errorCodeNumber: data.code,
                errorAccessToken: token.access_token
            };
            if (data.code === 11011) {
                data.type = 'refresh-removed';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token was removed (%s), and try check in remote-session.',
                    user.username, token.access_token, token.refresh_token, type
                );
                return tokenEvent.checkTokenInRemoteSession(context, token).then((newToken) => {
                    logger.info(
                        `user( %s ) token refresh success(%s), \nold token(A:%s, R:%s), \nnew token(A:%s, R:%s, E:%s)`,
                        user.username,
                        'checkTokenInRemoteSession',
                        token.access_token, token.refresh_token,
                        newToken.access_token, newToken.refresh_token, newToken.expires_in
                    );
                    tokenEvent.fireTokenRefreshed(context, newToken);
                    resolve(newToken);
                    delayAutoDelete(true);
                }).catch((error) => {
                    delayAutoDelete(true);
                    logger.warn(
                        'user(U: %s, A: %s, R: %s) refresh-token was removed (%s), and check was error: \n',
                        user.username, token.access_token, token.refresh_token, type,
                        (error && error.stack ? error.stack : error)
                    );
                    tokenEvent.fireTokenRefreshExpired(context, tokenEventData);
                    reject(data);
                });
            } else if (data.code === 11013) {
                data.type = 'refresh-expired';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token was expired (%s).',
                    user.username, token.access_token, token.refresh_token, type
                );
                tokenEvent.fireTokenRefreshExpired(context, tokenEventData);
            } else if (data.code === 11473) {
                data.type = 'refresh-sso-out';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token was sso-out (%s).',
                    user.username, token.access_token, token.refresh_token, type
                );
                tokenEvent.fireTokenSsoOut(context, tokenEventData);
            } else if (data.code === 11111) {
                data.type = 'refresh-kicked';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token was kicked (%s).',
                    user.username, token.access_token, token.refresh_token, type
                );
                tokenEvent.fireTokenKicked(context, tokenEventData);
            } else if (data.code === 11484) {
                data.type = 'refresh-manager-kicked';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token was kicked by manager (%s).',
                    user.username, token.access_token, token.refresh_token, type
                );
                tokenEvent.fireTokenKickedByManager(context, tokenEventData);
            } else {
                data.type = 'refresh-error';
                logger.warn(
                    'user(U: %s, A: %s, R: %s) refresh-token .O_o. (%s): \n',
                    user.username, token.access_token, token.refresh_token, type, error
                );
            }
            delayAutoDelete(true);
            reject(data);
        };

        logger.info(
            'user(U:%s, A:%s, R:%s, EA:%s) token was expired.',
            user.username, token.access_token, token.refresh_token,
            (new Date(token.expires_at)).toLocaleString()
        );

        return (strategy[token.refresh_token] = new Promise((resolve, reject) => {
            // 使用 process.nextTick 在发生运行时异常时，将不会调用 resolve 或 reject 方法, 而是出现 uncatchedException
            process.nextTick(() => {
                restler.post(config.tokenServerUrl, Object.assign({}, context, {
                    data: {
                        'client_id': config.appKey,
                        'client_secret': config.appSecret,
                        'grant_type': GRANT_TYPE.REFRESH_TOKEN,
                        'refresh_token': token.refresh_token
                    }
                })).on('error', function (error, response) {
                    errorHandler.call(this, 'error', error, response, reject, resolve);
                }).on('fail', function (error, response) {
                    errorHandler.call(this, 'fail', error, response, reject, resolve);
                }).on('success', function (result) {
                    const newToken = new AccessToken(result.access_token, result.expires_in, result.refresh_token);
                    newToken.refresh_time = Date.now();
                    delayAutoDelete();
                    logger.info(
                        'user(%s) token refresh success, \nold token(A:%s, R:%s), \nnew token(A:%s, R:%s, E:%s)',
                        user.username,
                        token.access_token, token.refresh_token,
                        newToken.access_token, newToken.refresh_token, newToken.expires_in
                    );
                    tokenEvent.fireTokenRefreshed(context, newToken);
                    resolve(newToken);
                });
            });
        }));
    }

    /**
     * 1. 获取 appToken
     * @param isForceRemoteFetch {boolean} 是否强制远程获取
     * @param isTimeoutReject {boolean} 是否需要在超时时调用 promise.reject() 方法
     * @return {Promise} {
     *      resolve: function(appToken) {}
     *      reject: function({type, data}) {}
     * }
     */
    fetchAppToken (isForceRemoteFetch, isTimeoutReject) {
        const self = this;
        return new Promise(function (resolve, reject) {
            // 使用 process.nextTick 在发生运行时异常时，将不会调用 resolve 或 reject 方法, 而是出现 uncatchedException
            process.nextTick(() => {
                if (
                    !isForceRemoteFetch && // 非强制远程获取 token
                    self.appToken && // token 存在
                    (self.appToken.expires_at - Date.now()) > 1000 * 60 * 1.5 // token 未过期（1.5分钟以上才算未过期）
                ) {
                    resolve(self.appToken);
                } else {
                    let isTimeout = false;
                    let timeoutid = 0;
                    if (isTimeoutReject) {
                        timeoutid = setTimeout(() => {
                            isTimeout = true;
                            // eslint-disable-next-line prefer-promise-reject-errors
                            reject({
                                type: 'timeout',
                                data: self[Progress]['appTokenFetchMaxTime']
                            });
                        }, self[Progress]['appTokenFetchMaxTime']);
                    }
                    self[RequestApplicationAccessToken]().then((token) => {
                        if (!isTimeout) {
                            clearTimeout(timeoutid);
                            resolve(token);
                        }
                    });
                }
            });
        });
    }

    /**
     * 2. 检测 errorCoceNumber 是否需要公共处理
     * @param errorCodeNumber
     */
    isGlobalUserTokenError (errorCodeNumber) {
        if (
            errorCodeNumber === 11011 ||
            errorCodeNumber === 11012 ||
            errorCodeNumber === 11111 ||
            errorCodeNumber === 11473 ||
            errorCodeNumber === 11484 ||
            errorCodeNumber === 11485 ||
            this[ForceUserOutErrorCodes]['' + errorCodeNumber]
        ) {
            return true;
        }
    }

    /**
     * 3. 处理 user token 的一些过期等问题
     * @param errorCodeNumber {int}
     * @param data {object} {
     *      token, user
     * }
     * @param context {object}
     * @return {EventEmitter} {
     *      token-refresh-successful         // 1. function(newToken) {}
     *      token-refresh-error              // 2. function(error, response) {}
     *      token-expired                    // 3. function() {}
     *      token-already-logout             // 4. function() {}
     * }
     */
    processUserTokenError (errorCodeNumber, data, context) {
        const self = this;
        const emitter = new EventEmitter();
        const token = data.token;
        const user = data.user;
        const tokenEventData = {
            errorType: '',
            errorCodeNumber: errorCodeNumber,
            errorAccessToken: token.access_token
        };
        if (errorCodeNumber === 11012) {
            // 1.1 拦截 token 过期异常（因无 refresh_token，所以抛出 token-expired 事件）
            // 注意：微应用中不直接操作 token 的刷新，交由主应用来刷新（因为token来自主应用），所以 token.refresh_token 需设置为 false
            if (!token || !token.refresh_token) {
                process.nextTick(function () {
                    tokenEvent.fireTokenExpired(context, tokenEventData);
                });
                return emitter;
            }
            // 1.2 拦截 token 过期异常（尝试自动刷新）
            self[RefreshUserAccessToken](token, user, context).then((newToken) => {
                emitter.emit('token-refresh-successful', newToken);
            }, ({ type, error, response }) => {
                if (type === 'refresh-error') {
                    emitter.emit('token-refresh-error', error, response);
                }
            });
        } else if (errorCodeNumber === 11011) {
            // 2. 拦截 token 不存在异常
            process.nextTick(function () {
                logger.warn('user(U: %s, A: %s) token was removed or not exist.', user.username, token.access_token);
                tokenEvent.fireTokenRemoved(context, tokenEventData);
            });
        } else if (errorCodeNumber === 11111) {
            // 3. 拦截 token所对应的用户 被踢异常
            process.nextTick(function () {
                logger.warn('user(U: %s, A: %s) token was kicked out.', user.username, token.access_token);
                tokenEvent.fireTokenKicked(context, tokenEventData);
            });
        } else if (errorCodeNumber === 11473) {
            // 4. 拦截 token 被单点退出了的异常
            process.nextTick(function () {
                logger.warn('user(U: %s, A: %s) token was kicked out (sso).', user.username, token.access_token);
                tokenEvent.fireTokenSsoOut(context, tokenEventData);
            });
        } else if (errorCodeNumber === 11484) {
            // 5. 拦截 token 被管理员强制退出的异常
            process.nextTick(function () {
                logger.warn('user(U: %s, A: %s) token was kicked out (manage).', user.username, token.access_token);
                tokenEvent.fireTokenKickedByManager(context, tokenEventData);
            });
        } else if (errorCodeNumber === 11485) {
            // 6. 拦截 token 已被正常退出的异常（两种情况：刷新之后导致的退出，直接退出后的再次使用；-- 通常忽略当前请求，就是临时失败处理）
            process.nextTick(function () {
                logger.warn('user(U: %s, A: %s) token was already logged out.', user.username, token.access_token);
                emitter.emit('token-already-logout');
            });
        } else if (self[ForceUserOutErrorCodes]['' + errorCodeNumber]) {
            // 7. 其它的一些必须强制用户退出系统的异常错误
            process.nextTick(function () {
                logger.warn(
                    'user(U: %s, A: %s) token occurred other force-out error(code: %s).',
                    user.username, token.access_token, errorCodeNumber
                );
                tokenEvent.fireTokenForceOut(context, tokenEventData);
            });
        }
        return emitter;
    }

    /**
     * 4. 检测 errorCoceNumber 是否需要公共处理
     * @param errorCodeNumber
     */
    isGlobalAppTokenError (errorCodeNumber) {
        if (
            errorCodeNumber === 11012 ||
            errorCodeNumber === 11011
        ) {
            return true;
        }
    }

    /**
     * 5. 处理 app token 的一些过期等问题
     * @param errorCodeNumber {int}
     * @return {EventEmitter} {
     *      token-reFetched                    // 1. function(token) {}
     * }
     */
    processAppTokenError (errorCodeNumber) {
        const self = this;
        const emitter = new EventEmitter();
        // 不管是 Token过期, 还是 Token不存在, 都自动的再次获取 appToken (非刷新机制)
        if (errorCodeNumber === 11012 || errorCodeNumber === 11011) {
            if (self.appToken) {
                logger.info(
                    'AppToken(A:%s, R:%s, EA:%s) was expired or invalid (code:%s).',
                    self.appToken.access_token, self.appToken.refresh_token,
                    (new Date(self.appToken.expires_at)).toLocaleString(), errorCodeNumber
                );
            }
            self.appToken = null;
            self.fetchAppToken(true, true).then(function (token) {
                emitter.emit('token-reFetched', token);
            }).catch((data) => {
                emitter.emit('token-error', data);
            });
        }
        return emitter;
    };

    /**
     * 6. 验证 token, 如果当前 token 正在请求刷新的过程中，则等待刷新结果，否则 Promise.resolve(token)
     * @param token {AccessToken}
     * @return {Promise} {
     *      resolve: function(token){}
     *      reject: function({type, error, response}){}
     * }
     */
    validateToken (token) {
        const strategy = this[Progress]['refreshTokenPromise'];
        if (token && token.refresh_token && strategy[token.refresh_token]) {
            return strategy[token.refresh_token];
        } else {
            return Promise.resolve(token);
        }
    };
}

const tokenProviderInstance = new TokenProvider();

// 程序启动时就已开始请求了 Application Access Token 数据了
if (config.appKey && config.appSecret) {
    process.nextTick(function () {
        tokenProviderInstance.fetchAppToken(true).catch(() => {});
    });
}

/**
 * 实例方法:
 * 1. fetchAppToken                         // function() {return promise}
 * 2. isGlobalUserTokenError                // function(errorCodeNumber) {return boolean}
 * 3. processUserTokenError                 // function(errorCodeNumber, data, context) {return eventEmitter}
 * 4. isGlobalAppTokenError                 // function(errorCodeNumber) {return eventEmitter}
 * 5. processAppTokenError                  // function(errorCodeNumber) {return eventEmitter}
 * 6. validateToken                         // function(token) {return promise}
 *
 * @type {TokenProvider}
 */
module.exports = tokenProviderInstance;
