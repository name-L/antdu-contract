/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 推送服务管理
 * Created by wuyaoqian on 2017/1/20.
 */

const EventEmitter = require('events');
const DataSdkRest = require('data-sdk-rest');
const TokenProvider = DataSdkRest.tokenProvider;
const DataManage = DataSdkRest.userDataManage;
const ErrorCodeUtil = DataSdkRest.errorCodeUtil;
const PushAddressManage = require('./push-address-manage');
const ConnectManage = require('./push-connect-manage');
const logger = require('log4js-config').get('eefung.data-sdk-socket.' + require('path').basename(__filename));

// 常量
const PUSH_SERVER_URL_KEY = '_PUSH_SERVER_URL_';
const CLIENT_SOCKET_IDS = '_CLIENT_SOCKET_IDS_';
const LATEST_SERVER_SOCKET = '_LATEST_SERVER_SOCKET_';
const ClientNSPS = Symbol('ClientNSPS');
const Listener = Symbol('Listener');
const CustomAdvancedErrors = Symbol('CustomAdvancedErrors');
const FetchUserTokenProgress = Symbol('FetchUserTokenProgress');
const ConnectPrepareProgress = Symbol('ConnectPrepareProgress');

// 在推送当中对外抛出的一些公共事件
const globalEvent = new EventEmitter();
// 存储自定义全局请求参数
const customGlobalHeaderObject = {
    sid: function (clientSocket) { return clientSocket.id; }
};
const customGlobalHeaderArray = [];
// 实例存储
const instances = {};

const PushManage = {
    [ClientNSPS]: {},
    [ConnectPrepareProgress]: {},
    /**
     * 0. 通过 sid 获取 clientSocket
     * @param {string} sid
     * @private
     * @return {*}
     */
    _getClientSocket (sid) {
        if (!sid || typeof sid !== 'string') { return null; }
        let temp = sid.split('#');
        let nsp = null;
        if (Array.isArray(temp) && temp.length === 2) {
            nsp = PushManage[ClientNSPS][temp[0]];
        } else {
            nsp = PushManage[ClientNSPS]['/'];
        }
        if (nsp) { return nsp.connected[sid]; }
    },
    /**
     * 0. 解析服务器返回的数据
     * 作用：
     * 1. 如果数据类型为 string, 则自动的将数据转换成 json object
     * 2. 自动的根据 socketId 找出对应的 clientSocket
     *
     * @param rawData {string|object}
     * @param key {string} receive key
     * @param serverSocketId {string} Push Server Socket Id
     * @private
     * @return {object}
     */
    _resolvePushServerData (rawData, key, serverSocketId) {
        let pushServer = this;
        let data = rawData;
        if (typeof rawData === 'string') {
            try {
                data = JSON.parse(rawData);
            } catch (error) {
                logger.error(
                    'PushReceive: receive malformed push data, key: %s, ssid: %s, rawData: ',
                    key, serverSocketId, rawData, ((error && error.stack) ? error.stack : error)
                );
            }
        }
        data = data || {};

        // sid格式：/topic-monitor#xxx-xxx-xxx
        data.socket = PushManage._getClientSocket(data.sid);
        if (!data.socket) {
            logger.warn(
                'PushReceive: client-socket missing when receive data, key: %s, id: %s, type: %s, \ncsid: %s, ssid: %s',
                key, data.id || '-', data.type || '-', data.sid, serverSocketId
            );
            pushServer[Listener].emit('system.client-socket-missing', {
                key: key,
                csid: data.sid,
                ssid: serverSocketId
            });
            globalEvent.emit('client-socket-missing', pushServer, {
                key: key,
                csid: data.sid,
                ssid: serverSocketId
            });
        }

        // instructTime
        data.instructTime = typeof data.instructTime === 'number' ? data.instructTime : 0;

        return data;
    },
    /**
     * 1. 获取 restInfo 信息
     * @param clientSocket
     * @return {Promise}
     */
    fetchRestInfo (clientSocket) {
        return new Promise((resolve, reject) => {
            let restInfo = DataManage.socketRequest.restInfo.get(clientSocket.request) || {};
            if (!restInfo.sid || !restInfo['session-store']) {
                return reject(new Error(`PushManage.fetchRestInfo: please login first, csid:${clientSocket.id}`));
            }
            resolve(restInfo);
        });
    },
    /**
     * 2. 获取用户 token 及 session
     * @param clientSocket {object} client socket
     * @return {Promise} {
     *      resolve: function({session, token}){}
     *      reject: function(detail) {}
     * }
     */
    fetchUserSessionAndToken (clientSocket) {
        let pushServer = this;
        let req = clientSocket.request;
        if (req[FetchUserTokenProgress]) {
            return req[FetchUserTokenProgress];
        }
        return (req[FetchUserTokenProgress] = new Promise((resolve, reject) => {
            PushManage.fetchRestInfo(clientSocket).then(function (restInfo) {
                restInfo['session-store'].get(restInfo.sid, function (err, sess) {
                    delete req[FetchUserTokenProgress];
                    if (err) { return reject(err); }
                    if (!sess || !DataManage.session.userToken.get(sess)) {
                        pushServer[Listener].emit('system.session-expired', clientSocket);
                        globalEvent.emit('session-expired', pushServer, clientSocket);
                        return reject(new Error(
                            `PushManage.fetchUserSessionAndToken: no session (id:${
                                restInfo.sid
                            }) or user (user:${
                                restInfo.username || '-'
                            }) token data found, csid:${clientSocket.id}`
                        ));
                    }
                    return resolve({
                        sess: sess,
                        restInfo: restInfo,
                        token: DataManage.session.userToken.get(sess)
                    });
                });
            }).catch((error) => {
                process.nextTick(() => {
                    delete req[FetchUserTokenProgress];
                    reject(error);
                });
            });
        }));
    },
    /**
     * 3. 监听 errors 事件
     * @param serverSocket {object} server socket
     * @param clientCustomEmitter {EventEmitter}
     * @return {PushManage}
     */
    registDataErrorEvents (serverSocket, clientCustomEmitter) {
        let pushServer = this;
        if (serverSocket._isRegistTokenEvent_) {
            return PushManage;
        }
        serverSocket._isRegistTokenEvent_ = true;
        serverSocket.on('errors', (rawData) => {
            let restInfo;
            let data = PushManage._resolvePushServerData.call(pushServer, rawData, 'errors', serverSocket.id);
            let socket = data.socket;
            let errorCodeObj = data.errorCode;
            let errorCodeNumber = data.errorCode
                ? (parseInt(data.errorCode['errorCode'] || data.errorCode['error_code']) || false)
                : false;
            if (!socket || !socket.id) {
                return;
            }
            delete data.socket;
            restInfo = DataManage.socketRequest.restInfo.get(socket.request) || {};

            // 开始处理非用户 Token 相关的错误
            if (!errorCodeNumber || !TokenProvider.isGlobalUserTokenError(errorCodeNumber)) {
                logger.error(
                    'receive other-error(push), user: %s, code:%s \ncsid: %s, ssid: %s\n',
                    restInfo.username || '-', errorCodeNumber || '-', socket.id, serverSocket.id, data
                );
                delete data.errorCode;
                let handler = clientCustomEmitter[CustomAdvancedErrors].find(function (obj) {
                    let temp = data;
                    obj.tKey.some((key) => {
                        return !(temp = temp[key]);
                    });
                    return temp === obj.tVal;
                });
                clientCustomEmitter.emit(handler ? handler.hKey : 'errors',
                    socket, ErrorCodeUtil.getErrorCodeDesc(errorCodeObj, restInfo.lang || socket.request), data
                );
                return;
            }

            // 开处理用户 Token 相关的错误
            let tokenFetchPromise = null;
            let errorAccessToken = data.errorCode.data ? (data.errorCode.data.token || '') : '';
            logger.warn(
                'receive auth-error(push), user: %s, code: %s, \nerror-token: %s, csid: %s, ssid: %s',
                restInfo.username || '-', errorCodeNumber, errorAccessToken || '-', socket.id, serverSocket.id
            );
            if (socket.token) {
                tokenFetchPromise = Promise.resolve({
                    token: { access_token: socket.token.access_token || socket.token }
                });
            } else {
                tokenFetchPromise = PushManage.fetchUserSessionAndToken.call(pushServer, socket);
            }
            tokenFetchPromise.then(({ sess, token }) => {
                if (errorAccessToken !== token.access_token) {
                    // eslint-disable-next-line prefer-promise-reject-errors
                    return Promise.reject({
                        type: 'push-error-ignored',
                        token: token
                    });
                }
                return Promise.all([
                    Promise.resolve(sess),
                    TokenProvider.validateToken(token)
                ]);
            }).then(([sess, token]) => {
                if (errorAccessToken !== token.access_token) {
                    // eslint-disable-next-line prefer-promise-reject-errors
                    return Promise.reject({
                        type: 'push-error-ignored',
                        token: token
                    });
                }
                TokenProvider.processUserTokenError(errorCodeNumber, {
                    token: token,
                    user: {
                        username: restInfo.username,
                        userid: restInfo.userid
                    }
                }, {
                    socket: socket,
                    socket_push_server: pushServer,
                    socket_session: sess
                });
            }).catch((error) => {
                if (error && error.type === 'push-error-ignored' && error.token) {
                    logger.warn(
                        'ignored auth-error(push), user: %s, code: %s, \nerror-token: %s, cur-token: %s, csid: %s',
                        restInfo.username || '-', errorCodeNumber, errorAccessToken || '-',
                        error.token.access_token, socket.id
                    );
                } else {
                    logger.error(
                        'PushManage.registTokenErrorEvents: process token catch error: ',
                        (error && error.stack ? error.stack : error || '-')
                    );
                }
            });
        });
        return PushManage;
    },
    /**
     * 4. 将用户的自定义监听事件附加在 server socket 上
     * @param serverSocket {object} server socket
     * @param clientCustomEmitter {EventEmitter}
     * @return {PushManage}
     */
    registUserCustomEvents (serverSocket, clientCustomEmitter) {
        let pushServer = this;
        if (serverSocket._isRegistCustomEvent_) {
            return PushManage;
        }
        serverSocket._isRegistCustomEvent_ = true;
        clientCustomEmitter.eventNames().forEach(function (key) {
            // 注意：errors 事件不能直接监听，在 registDataErrorEvents 中会有专门的监听
            if (
                key.match(clientCustomEmitter[CustomAdvancedErrors]['regexps'][0]) ||
                key.match(clientCustomEmitter[CustomAdvancedErrors]['regexps'][1])
            ) {
                return;
            }
            serverSocket.on(key, (rawData) => {
                let data = PushManage._resolvePushServerData.call(pushServer, rawData, key, serverSocket.id);
                let socket = data.socket;
                if (!socket || !socket.id) {
                    return;
                }
                logger.info(
                    'receive data (key: %s, id: %s, type: %s) success, time(instruct): %ss, \ncsid: %s, ssid: %s',
                    key, data.id || '-', data.type || '-',
                    data.instructTime ? (Date.now() - data.instructTime) / 1000 : '-',
                    socket ? socket.id : '-', serverSocket.id
                );
                delete data.socket;
                clientCustomEmitter.emit(key, socket, data);
            });
        });
        return PushManage;
    },
    /**
     * 5. 获取长连接的相关参数
     * @param clientSocket {Socket} 浏览器的 ClientSocket
     * @return {Promise} {
     *      resolve: function({baseUrl}){}
     *      reject: function() {}
     * }
     */
    fetchConnectParams (clientSocket) {
        let pushServer = this;
        let req = clientSocket.request;
        if (PushManage[ConnectPrepareProgress][pushServer.key]) {
            return PushManage[ConnectPrepareProgress][pushServer.key];
        }
        if (!req[PUSH_SERVER_URL_KEY]) {
            req[PUSH_SERVER_URL_KEY] = {};
        }
        return (PushManage[ConnectPrepareProgress][pushServer.key] = new Promise(function (resolve, reject) {
            if (!req[PUSH_SERVER_URL_KEY][pushServer.key]) {
                pushServer.addressManage.fetch().on('success', (url) => {
                    delete PushManage[ConnectPrepareProgress][pushServer.key];
                    req[PUSH_SERVER_URL_KEY][pushServer.key] = url;
                    resolve({
                        baseUrl: url
                    });
                }).on('error', (error) => {
                    delete PushManage[ConnectPrepareProgress][pushServer.key];
                    reject(
                        error ||
                        new Error(`pushServer.addressManage.fetch() catch error, id: ${pushServer.addressManage.id}`)
                    );
                });
            } else {
                process.nextTick(() => {
                    delete PushManage[ConnectPrepareProgress][pushServer.key];
                    resolve({
                        baseUrl: req[PUSH_SERVER_URL_KEY][pushServer.key]
                    });
                });
            }
        }));
    },
    /**
     * 6. 获取自定义全局请求参数
     * @param clientSocket
     * @return {{}}
     */
    getGlobalHeaderParams: function (clientSocket) {
        let params = {};
        customGlobalHeaderArray.forEach(function (fn) {
            params = Object.assign(params, fn(clientSocket));
        });
        Object.keys(customGlobalHeaderObject).forEach(function (key) {
            params[key] = (typeof customGlobalHeaderObject[key] === 'function')
                ? customGlobalHeaderObject[key](clientSocket)
                : customGlobalHeaderObject[key];
            if (!params[key]) {
                delete params[key];
            }
        });
        return params;
    },
    /**
     * 7. 在 serverSocket 中记录所有通过此连接发送信息的 clientSocket
     * @param clientSocket
     * @param serverSocket
     */
    recordClientSocket (clientSocket, serverSocket) {
        let pushServer = this;
        if (!serverSocket[CLIENT_SOCKET_IDS]) {
            serverSocket[CLIENT_SOCKET_IDS] = {};
        }
        if (!clientSocket['_isRegisterDisconnectEvent_']) {
            clientSocket['_isRegisterDisconnectEvent_'] = true;
            clientSocket.on('disconnect', () => {
                if (clientSocket[LATEST_SERVER_SOCKET]) {
                    // 删除 serverSocket(最近一次 clientSocket 中关联的 serverSocket) 中记录的指定 clientSocket
                    delete clientSocket[LATEST_SERVER_SOCKET][CLIENT_SOCKET_IDS][clientSocket.id];
                    // 删除 serverSocket(最近一次 clientSocket 中关联的 serverSocket)
                    delete clientSocket[LATEST_SERVER_SOCKET];
                }
            });
        }
        // 删除 serverSocket(上次 clientSocket 中关联的 serverSocket) 中记录的指定 clientSocket
        if (clientSocket[LATEST_SERVER_SOCKET]) {
            delete clientSocket[LATEST_SERVER_SOCKET][CLIENT_SOCKET_IDS][clientSocket.id];
        }
        // 将 serverSocket 关联在 clientSocket 上
        clientSocket[LATEST_SERVER_SOCKET] = serverSocket;
        // 将 clientSocket 记录在 serverSocket 上
        serverSocket[CLIENT_SOCKET_IDS][clientSocket.id] = pushServer;
    }
};

/**
 * 推送服务
 * @param namespace
 * @param aid
 * @constructor
 */
class PushServer {
    constructor (namespace, addressManage, opt) {
        this.key = addressManage.id;
        this.addressManage = addressManage;
        this.namespace = namespace.replace(/^\/*/, '/');
        this[Listener] = new EventEmitter();
        this[Listener][CustomAdvancedErrors] = [];
        this[Listener][CustomAdvancedErrors].regexps = [
            /^errors(\.([^.:]+):([^:]+))?$/,
            /^errors(\[([^.=[\]]+)=([^=[\]]+)])?$/
        ];
        this.ackTimeoutTime = 1000 * 10;
    }

    /**
     * 1. 往推送服务器发送消息（自动的在 value 中加入两个参数：token, socketId）
     * @param clientSocket {object} client socket
     * @param key {string}
     * @param value {object}
     * @param ack {function|undefined} 确认回调函数
     */
    userEmit (clientSocket, key, value, ack) {
        const self = this;
        PushManage[ClientNSPS][clientSocket.nsp.name] = clientSocket.nsp;
        PushManage.fetchConnectParams.call(self, clientSocket).then(({ baseUrl }) => {
            return ConnectManage.tryConnect(baseUrl, self.namespace);
        }).then((serverSocket) => {
            PushManage.registUserCustomEvents.call(self, serverSocket, self[Listener]);
            PushManage.registDataErrorEvents.call(self, serverSocket, self[Listener]);
            // 到 session 中获取 token
            if (!clientSocket.token) {
                return Promise.all([
                    Promise.resolve(serverSocket),
                    PushManage.fetchUserSessionAndToken.call(self, clientSocket)
                ]);
            }
            // 直接在 clientSocket 中获取 token
            return Promise.all([
                Promise.resolve(serverSocket),
                PushManage.fetchRestInfo(clientSocket).then(function (restInfo) {
                    return Promise.resolve({
                        restInfo: restInfo,
                        token: { access_token: clientSocket.token.access_token || clientSocket.token }
                    });
                })
            ]);
        }).then(([serverSocket, data]) => {
            return Promise.all([
                Promise.resolve(serverSocket),
                TokenProvider.validateToken(data.token),
                Promise.resolve(data.restInfo)
            ]);
        }).catch((error) => {
            if (clientSocket.request[PUSH_SERVER_URL_KEY]) {
                delete clientSocket.request[PUSH_SERVER_URL_KEY][self.key];
            }
            return Promise.reject(error);
        }).then(([serverSocket, token, restInfo]) => {
            let val = Object.assign({
                id: Date.now() + '-' + parseInt(Math.random() * 10000),
                instructTime: Date.now()
            }, value, PushManage.getGlobalHeaderParams(clientSocket), {
                token: token.access_token
            });
            let timeid = setTimeout(() => {
                logger.warn(
                    'send command (key: %s, id: %s, type: %s) with token receive ack timeout: %ss, ' +
                    '\nuser: %s, csid: %s, ssid: %s',
                    key, val.id, val.type || '-', self.ackTimeoutTime / 1000,
                    restInfo.username || '-', clientSocket.id, serverSocket.id
                );
            }, self.ackTimeoutTime);
            logger.debug(
                'sending command (key: %s, id: %s, type: %s) with token, \nuser: %s, csid: %s, ssid: %s',
                key, val.id, val.type || '-', restInfo.username || '-', clientSocket.id, serverSocket.id
            );
            serverSocket.emit(key, JSON.stringify(val), () => {
                clearTimeout(timeid);
                logger.info(
                    'send command (key: %s, id: %s, type: %s) with token success and taking: %ss, ' +
                    '\nuser: %s, csid: %s, ssid: %s',
                    key, val.id, val.type || '-', (Date.now() - val.instructTime) / 1000,
                    restInfo.username || '-', clientSocket.id, serverSocket.id
                );
                PushManage.recordClientSocket.call(self, clientSocket, serverSocket);
                if (typeof ack === 'function') { ack(); }
            });
        }).catch((error) => {
            logger.error('userEmit catch error: ', (error && error.stack ? error.stack : error || '-'));
        });
    }

    /**
     * 2. 往推送服务器发送消息（自动的在 value 中加入一个参数：socketId）
     * @param clientSocket {object} client socket
     * @param key {string}
     * @param value {object}
     * @param ack {function|undefined} 确认回调函数
     */
    socketEmit (clientSocket, key, value, ack) {
        const self = this;
        PushManage[ClientNSPS][clientSocket.nsp.name] = clientSocket.nsp;
        PushManage.fetchConnectParams.call(self, clientSocket).then(({ baseUrl }) => {
            return ConnectManage.tryConnect(baseUrl, self.namespace);
        }).then((serverSocket) => {
            PushManage.registUserCustomEvents.call(self, serverSocket, self[Listener]);
            PushManage.registDataErrorEvents.call(self, serverSocket, self[Listener]);
            return Promise.resolve(serverSocket);
        }).catch((error) => {
            if (clientSocket.request[PUSH_SERVER_URL_KEY]) {
                delete clientSocket.request[PUSH_SERVER_URL_KEY][self.key];
            }
            return Promise.reject(error);
        }).then((serverSocket) => {
            let val = Object.assign({
                id: Date.now() + '-' + parseInt(Math.random() * 10000),
                instructTime: Date.now()
            }, value, PushManage.getGlobalHeaderParams(clientSocket));
            let timeid = setTimeout(() => {
                logger.warn(
                    'send command (key: %s, id: %s, type: %s) receive ack timeout: %ss, \ncsid: %s, ssid: %s',
                    key, val.id, val.type || '-', self.ackTimeoutTime / 1000, clientSocket.id, serverSocket.id
                );
            }, self.ackTimeoutTime);
            logger.debug(
                'sending command (key: %s, id: %s, type: %s), \ncsid: %s, ssid: %s',
                key, val.id, val.type || '-', clientSocket.id, serverSocket.id
            );
            serverSocket.emit(key, JSON.stringify(val), () => {
                clearTimeout(timeid);
                logger.info(
                    'send command (key: %s, id: %s, type: %s) success and taking: %ss, \ncsid: %s, ssid: %s',
                    key, val.id, val.type || '-', (Date.now() - val.instructTime) / 1000,
                    clientSocket.id, serverSocket.id
                );
                PushManage.recordClientSocket.call(self, clientSocket, serverSocket);
                if (typeof ack === 'function') {
                    ack();
                }
            });
        }).catch((error) => {
            logger.error('socketEmit catch error: ', (error && error.stack ? error.stack : error || '-'));
        });
    }

    /**
     * 3. 监听服务器返回的数据
     * @param key {string} key
     *      注意1：支持如下高级错误事件的监听格式（但不支持除 errors 事件以外的高级监听模式）
     *      1: errors.alarm:instruct.dataType , 事例：on(
     *            "errors.alarm:instruct.dataType", function(socket, errorCodeDesc, data){}
     *         )
     *      2：errors[alarm=instruct.dataType], 事例：on(
     *            "errors[alarm=instruct.dataType]", function(socket, errorCodeDesc, data){}
     *         )
     *      原理：
     *      if(data["instruct"]["dataType"] === "alarm") {
     *          emit("errors.alarm:instruct.dataType", socket, errorCodeDesc, data)
     *          // or
     *          emit("errors[alarm=instruct.dataType]", socket, errorCodeDesc, data)
     *      } else {
     *          emit("errors", socket, errorCodeDesc, data)
     *      }
     *
     *      注意2：这里还会有系统级别的事件抛出
     *      1：system.session-expired      // function(clientSocket){}
     *      2：system.socket-missing       // function({key, csid, ssid}){}
     *      3: system.server-disconnected  // function(clientSocket){}
     *      4: system.token-expired        // function(clientSocket, {errorCodeNumber, errorAccessToken})
     *
     * @param fn {function} 回调函数        // function(socket, data) {}
     */
    on (key, fn) {
        this[Listener].on(key, fn);

        // 注意：errors 事件不能直接监听，在 registDataErrorEvents 中会有专门的监听
        // 1:
        // keyMatch[0] = errors.alarm:instruct.dataType
        // keyMatch[1] = .alarm:instruct.dataType
        // keyMatch[2] = alarm
        // keyMatch[3] = instruct.dataType
        // 2:
        // keyMatch[0] = errors[alarm=instruct.dataType]
        // keyMatch[1] = [alarm=instruct.dataType]
        // keyMatch[2] = alarm
        // keyMatch[3] = instruct.dataType
        let keyMatch;
        let advancedErrors = this[Listener][CustomAdvancedErrors];
        if ((keyMatch = key.match(advancedErrors.regexps[0])) && keyMatch[1]) {
            advancedErrors.push({
                hKey: key,
                tKey: keyMatch[3].split('.'),
                tVal: keyMatch[2]
            });
        } else if ((keyMatch = key.match(advancedErrors.regexps[1])) && keyMatch[1]) {
            advancedErrors.push({
                hKey: key,
                tKey: keyMatch[3].split('.'),
                tVal: keyMatch[2]
            });
        }

        return this;
    }
}

// 监听连接断开事件
ConnectManage.events.on('server-disconnected', function (serverSocket, data) {
    // 1. 根据发送记录，通知相应的连接（服务连接已断开）
    let ids = serverSocket[CLIENT_SOCKET_IDS] || {};
    Object.keys(ids).forEach((csid) => {
        // csid格式：/topic-monitor#xxx-xxx-xxx
        let temp, clientSocket, pushServer;
        if (
            !csid || typeof csid !== 'string' || //                              csid 的合法性检测 1
            !Array.isArray(temp = csid.split('#')) || //                         csid 的合法性检测 2
            temp.length !== 2 || //                                              csid 的合法性检测 3
            !(clientSocket = PushManage[ClientNSPS][temp[0]].connected[csid]) // 根据 csid 找到的 clientSocket 的连接状态检测
        ) {
            return;
        }
        pushServer = ids[csid];
        if (pushServer) {
            pushServer[Listener].emit('system.server-disconnected', clientSocket, data);
        }
        globalEvent.emit('server-disconnected', pushServer, clientSocket, data);
    });
    // 2. 清空历史发送记录
    serverSocket[CLIENT_SOCKET_IDS] = {};
});

module.exports = {
    /**
     * 抛出的一些公共事件
     * 1. session-expired             // function(instance, clientSocket) {}
     * 2. client-socket-missing       // function(instance, {key, csid, ssid}) {}
     * 3. server-disconnected         // function(instance, clientSocket, {type, reason}){}
     * 4. token-expired               // function(instance, clientSocket, {errorCodeNumber, errorAccessToken}) {}
     */
    events: globalEvent,
    /**
     * 添加自定义的全局请求参数
     * @param key {string|function}
     * @param val {string|function} function: val(socket)
     */
    addCustomGlobalHeader: function (key, val) {
        if (typeof key === 'function') {
            customGlobalHeaderArray.push(key);
            return this;
        }
        if (typeof key === 'string' && key) {
            // 忽略 token, sid 这两个 key
            if (key === 'token' || key === 'sid') {
                logger.warn('ignored customGlobalHeader: ', key);
                return this;
            }
            // 强行将 user-agent 换成标准的 User-Agent
            if (key === 'user-agent') {
                key = 'User-Agent';
            }
            if (val && (typeof val === 'string' || typeof val === 'function')) {
                customGlobalHeaderObject[key] = val;
            }
        }
        return this;
    },
    /**
     * 根据 sid 获取 ClientSocket
     * @param {string} sid
     * @return {*}
     */
    getClientSocket: function (sid) {
        return PushManage._getClientSocket(sid);
    },
    /**
     * 获取推送服务实例
     * @param {string} namespace - 格式如：/topic-monitor
     * @param {object} addressManageConfig - 推送服务器所在的地址的服务的相关配置
     * @param {string} addressManageConfig.type
     * @oaram {object} addressManageConfig.config
     * @param {object} opt - 其它选项
     *
     * @return {PushServer} {
     *      userEmit: function(socket, key, value, ack) {}
     *      socketEmit: function(socket, key, value, ack) {},
     *      on: function(key, function(socket, data){}) {}
     * }
     */
    getInstance: function (namespace, addressManageConfig, opt) {
        if (!addressManageConfig || !addressManageConfig.type || !PushAddressManage[addressManageConfig.type]) {
            throw new Error('param addressManageConfig.type incorrect!');
        }
        let addressManage = PushAddressManage[addressManageConfig.type].getInstance(addressManageConfig.config);
        let key = `_${namespace}-${addressManage.id}_`;
        return (instances[key] = instances[key] || new PushServer(namespace, addressManage, opt));
    }
};
