/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * log4js-restlet 扩展
 * Created by YuanZhengwen on 2020/3/18.
 */
const axios = require('axios');
const layouts = require('log4js').layouts;
const messagePassThroughLayout = layouts.messagePassThroughLayout;
const CONSOLE_FLAG_DATA = {};
const appenderFlushList = [];
const remoteAddr = require('./ip-utils').getServerIp();
const SYSTEM_ERROR_LEVEL = 10000 * 10000;

// 获取日志消息ID
const getLogId = (logItem) => {
    return logItem.level !== SYSTEM_ERROR_LEVEL ?
        `${logItem.levelStr} & ${logItem.context} # ${logItem._orgMessage || logItem.message}` : {};
};

/**
 * 创建appender
 * @param layout
 * @param config
 * @param options
 * @param done
 * @return {function(...[*]=)}
 */
function createAppender (layout, config, options, done) {
    let buffers = [];
    let preSubmitTime = Date.now();

    // 请求缺省参数
    const requestDefaultOpt = {
        url: config.url,
        timeout: typeof (config.timeout) !== 'number' ? config.timeout : 30 * 1000,
        headers: Object.assign({
            'Content-Type': 'application/json',
            applicationName: config.indexName || 'vue-demo',
            remoteAddr: remoteAddr
        }, config.headers),
        params: config.params,
        method: config.method || 'post',
        maxContentLength: config.maxContentLength || Infinity
    };

    // 日志发布到到通道
    const channel = config.channel || ('log4js-restlet-nodejs' + '#' + process.cwd());

    // 标签
    const tags = (Array.isArray(config.tags) ? config.tags :
        typeof (config.tags) === 'string' ? [config.tags] : [])
        .map(d => d.trim()).filter(d => !!d).join(' ');

    // 错误回调函数
    const errorCallback = (error) => {
        let message = error.response ?
            `log4js-restlet Appender error posting to ${config.url}:${error.response.status} - ${error.response.data}` :
            `log4js-restlet Appender error: ${error.message}`;

        console.error(message, CONSOLE_FLAG_DATA);

        // 记录一次提交日志错误信息
        buffers.push({
            level: SYSTEM_ERROR_LEVEL,
            levelStr: 'ERROR',
            datatime: Date.now(),
            channel: channel,
            message: message,
            context: 'log4js-restlet.js',
            thrown: '',
            tags: tags
        });
    };

    // 缓存条数
    const buffersize = config.buffersize || 512;

    // 限速间隔
    const limitSubmitPreMilliseconds = config.limitSubmitPreMilliseconds || 1000;

    // 限制速度多少条/毫秒
    const limitSubmitSpeedByMilliseconds = (config.limitSubmitPreCount || 150) / limitSubmitPreMilliseconds;

    // 立即提交
    const flushBuffers = (forceFlush) => {
        if (buffers.length) {
            let splitTime = (Date.now() - preSubmitTime);
            let max = Math.floor(splitTime * limitSubmitSpeedByMilliseconds);

            if (buffers.length >= max) {
                if (!forceFlush && buffers.length < buffersize) {
                    return;
                }

                // 合并日志
                let logIds = buffers.map(getLogId);
                buffers = buffers.filter((d, i) => {
                    let logId = logIds[i];
                    if (logId) {
                        let count = 0;
                        while ((i = logIds.indexOf(logId, i + 1)) > 0) {
                            logIds[i] = null;
                            count++;
                        }
                        if (count) {
                            d._count = count + (d._count || 1);
                            d._orgMessage = d._orgMessage || d.message;
                            d.message = `【日志频率超限，自动合并${d._count}条相同日志】${d._orgMessage || d.message}`;
                        }
                        return true;
                    }
                });

                // 按日志基本进行排序，并优先截取级别高的日志
                let mergeLogCount = buffers.length;
                if (mergeLogCount >= max) {
                    buffers = buffers.sort(d => d.level || 0).slice(buffers.length - max + 1);
                }

                // 添加超限日志条目
                buffers.push({
                    level: SYSTEM_ERROR_LEVEL,
                    levelStr: 'ERROR',
                    datatime: Date.now(),
                    channel: channel,
                    message: `log4js-restlet-nodejs limit submit logs speed (realLogCount=${
                        logIds.length}, afterMergeLogCount=${mergeLogCount}, currentMax=${
                        max}, dropLogCount=${Math.max(0, mergeLogCount - max - 1)}, recordTime=${
                        splitTime}ms, currentSpeed=${
                        Math.round(logIds.length * 1000 / splitTime)}/s, maxLimitSpeed=${
                        Math.round(limitSubmitSpeedByMilliseconds * 1000)
                    }/s) !`,
                    context: 'log4js-restlet.js',
                    thrown: '',
                    tags: tags
                });
            }

            // 限制最小提交间隔，同时提交日志的线程数也随之限制住了
            if (!forceFlush && splitTime < limitSubmitPreMilliseconds) {
                return;
            }

            let promise = axios.request(Object.assign({data: buffers}, requestDefaultOpt)).catch(errorCallback);
            buffers = [];
            preSubmitTime = Date.now();
            return promise;
        }
    };
    appenderFlushList.push(flushBuffers);

    // 定时flush，确保不会出现长时间不提交情况
    setInterval(flushBuffers, requestDefaultOpt.timeout);

    if (typeof (done) === 'function') {
        done();
    }

    return function (event) {
        if (event.categoryName === 'console' && event.data[1] === CONSOLE_FLAG_DATA) {
            return;
        }

        let data = __formatData(event);
        let message = data[0], errorMsg = data[1], stack = data[2];

        buffers.push({
            level: event.level.level,
            levelStr: event.level.levelStr,
            datatime: event.startTime.getTime(),
            channel: channel,
            message: message,
            context: event.categoryName,
            thrown: stack,
            tags: tags
        });

        if (buffers.length >= buffersize) {
            flushBuffers();
        }
    };
}

/**
 * 初始化配置
 * @param config
 * @param options
 * @param done
 * @return {function(...[*]=)}
 */
function configure (config, options, done) {
    return createAppender(null, config, options, done);
}

/**
 * 提交日志
 */
function flushAll (forceFlush, callback) {
    let promise = Promise.all(appenderFlushList.map(d => {
        return (d(forceFlush) || Promise.resolve(true)).catch(err => Promise.resolve(err));
    }));
    if (typeof (callback) === 'function') {
        promise.then(() => process.nextTick(callback));
    }
}

/**
 * Extracts the message, error-message and stack track.
 */
function __formatData (loggingEvent) {
    let data = loggingEvent.data;
    let message, errorMsg, stack;
    if (data[data.length - 1] instanceof Error) {
        let error = data[data.length - 1];
        errorMsg = error.message;
        if (typeof error.stack === 'string') {
            stack = error.stack.split('\n');
        } else {
            stack = error.stack;
        }
        data = data.splice(0, data.length - 1);
        message = messagePassThroughLayout({data: data});
    } else {
        message = messagePassThroughLayout(loggingEvent);
    }
    return [message, errorMsg, stack];
}

exports.appender = createAppender;
exports.configure = configure;
exports.flushAll = flushAll;
