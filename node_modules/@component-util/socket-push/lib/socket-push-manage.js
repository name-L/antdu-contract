/*!
 * Copyright (c) 2010-2017 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2017 湖南蚁坊软件有限公司。保留所有权利。
 */

"use strict";

import sio from 'socket.io-client';
import PushTimer from './socket-push-timer.js';

/**
 * 推送管理中心
 * 使用方法:
 * import PushManage from '@component-util/socket-push';
 *
 * // 方法: PushManage.XXX
 * 0. setup                   // function(manageOpt, connectOpt) {}
 * 1. getPushServer           // function(namespace){return socket}
 * 2. closePushServer         // function(key, tip) {}
 *
 * Created by wuyaoqian on 2017-9-21.
 */

const getOpt = function (nsp, path, host) {
    let _host = host || window.location.host;
    let _path = path || PushManage._opts.connect.path;
    return {
        path: _path,
        host: _host,
        id: `"${nsp}", "${_path}", "${_host}"`
    };
};

const PushManage = {
    /**
     * {namespace: socket, ...}
     */
    _sockets: {},
    _isInited: {},
    _isClosed: {},
    _opts: {
        // 连接的相关默认选项
        connect: {
            path: '/socket.io',
            transports: ['websocket'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 28 * 1000,
            reconnectionAttempts: Infinity,
            receiveTimeout: 3000,
            receiveTimeoutMax: 28 * 1000,
            receiveTimeoutAttempts: 3
        },
        // 管理的默认选项
        manage: {
            /**
             * 关闭连接前的回调
             * @param key {string}
             * @param path {string}
             * @param host {string}
             * @return {boolean} {
             *      return true;    // 继续断开连接（默认值）；
             *      return false;   // 中止断开连接；
             * }
             */
            beforeClosePushServer: function (key, path, host) {
                return true;
            },
            /**
             * 关闭连接后的回调
             * @param key
             * @param tip
             * @param url
             * @param path
             * @param host
             */
            afterClosePushServer: function (key, tip, url, path, host) {
                if (tip && typeof tip === "string") {
                    alert(tip);
                }
                if (url && typeof url === "string") {
                    window.location.href = url;
                }
            },
            /**
             * 关闭连接后界面的重定向地址
             */
            redirectToUrlAfterClose: "/login"
        }
    },
    _onError: function (reason, path, host) {
        let ret = /^(401|need-login)\s*:\s*(.+)$/.exec(reason);
        if (ret) {
            PushManage.closePushServer("401", ret[2], path, host);
        }
    },
    _initFastClose: function () {
        let manage = this;
        let rt = PushManage._opts.connect.receiveTimeout;
        let rta = PushManage._opts.connect.receiveTimeoutAttempts;
        let rtm = PushManage._opts.connect.receiveTimeoutMax;
        let level = ['debug', 'info', 'warn'].slice(Math.max(0, 3 - rta));
        let onPacketCreate = function () {
            let self = this;
            let data = self.__rt__ = self.__rt__ || {
                attempts: 0,
                delay: [Math.min(rt, rtm)],
                tid: 0
            };
            if (data.tid) { return; }
            if (data.attempts > 0) {
                let ct = data.attempts === 1 ? 500 : 1000;
                let rd = parseInt(Math.random() * ct);
                data.delay.push(Math.min(
                    rtm, (data.delay[data.delay.length - 1] * 2) + ((rd > (ct / 2)) ? -rd : rd)
                ));
            }
            data.tid = setTimeout(function () {
                if ('closed' === self.readyState) { return; }
                data.attempts = data.attempts + 1;
                console[level[Math.min(data.attempts - 1, level.length - 1)]](
                    'Socket.IO (%s) connection unstable, times: %s, delay: ',
                    manage.__oid__, data.attempts, data.delay[data.delay.length - 1]
                );
                if (data.attempts >= rta) {
                    delete self.__rt__;
                    return self.onClose('receive timeout');
                }
                data.tid = 0;
                manage.emit('receive-timeout', data.delay);
                clearTimeout(self.pingIntervalTimer);
                self.ping();
            }, data.delay[data.delay.length - 1]);
        };
        let onHeartbeat = function () {
            this.__rt__ && this.__rt__.tid && clearTimeout(this.__rt__.tid);
            this.__rt__ && this.__rt__.attempts >0 && this.emit('receive-restore', this.__rt__.attempts);
            delete this.__rt__;
        };
        let onClose = function () {
            this.removeListener('packetCreate', onPacketCreate);
            this.removeListener('heartbeat', onHeartbeat);
            manage.once('open', PushManage._initFastClose);
        };
        manage.engine.on('packetCreate', onPacketCreate).on('heartbeat', onHeartbeat).once('close', onClose);
    },
    _tryInit: function (options) {
        let socket;
        let opt = getOpt('/', options && options.path, options && options.host);
        if (PushManage._isInited[opt.id]) {
            return;
        }
        PushManage._isInited[opt.id] = true;

        // 初始化根目录的连接
        socket = PushManage.getPushServer("/", options);

        // 初始化自定义检测连接断开逻辑
        socket.io.__oid__ = opt.id;
        PushManage._initFastClose.call(socket.io);

        // 底层连接相关事件
        socket.on("connect", function () {
            console.info("successfully established a working connection Socket.IO (%s)", opt.id);
        }).on("disconnect", function (reason) {
            console.warn("Socket.IO (%s) was disconnected, reason: ", opt.id, reason);
        }).on("error", function (reason) {
            console.error("connect Socket.IO (%s) has error, reason: ", opt.id, reason);
            PushManage._onError(reason, opt.path, opt.host);
        });

        // token 相关事件
        socket.on("token-refresh-expired", function (msg) {
            PushManage.closePushServer("token-refresh-expired", msg, opt.path, opt.host);
        }).on("token-not-exist", function (msg) {
            PushManage.closePushServer("token-not-exist", msg, opt.path, opt.host);
        }).on("token-was-kicked", function (msg) {
            PushManage.closePushServer("token-was-kicked", msg, opt.path, opt.host);
        }).on("token-was-kicked-by-sso", function (msg) {
            PushManage.closePushServer("token-was-kicked-by-sso", msg, opt.path, opt.host);
        }).on("token-force-out", function (msg) {
            PushManage.closePushServer("token-force-out", msg, opt.path, opt.host);
        });

        // session 过期
        socket.on("session-expired", function (msg) {
            PushManage.closePushServer("session-expired", msg, opt.path, opt.host);
        });

        // // 其它业务事件（可在外面扩展）
        // socket.on("kick-offline", function (msg) {
        //     PushManage.closePushConnection("kick-offline", msg, opt.path, opt.host);
        // });

    },
    /**
     * 关闭与推送服务器之间的连接
     */
    closePushServer: function (key, tip, path, host) {
        let isContinue = true;
        let opt = getOpt('/', path, host);
        if (PushManage._isClosed[opt.id]) { return; }
        if (typeof PushManage._opts.manage.beforeClosePushServer === "function") {
            isContinue = PushManage._opts.manage.beforeClosePushServer(key, opt.path, opt.host);
        }
        if (!isContinue) {return;}
        PushManage._isClosed[opt.id] = true;
        PushManage._sockets[opt.id].io.close();
        console.warn("[Push: %s, Path: %s, Host: %s] session timeout or logout, so close the push connection.", key, opt.path, opt.host);
        if (typeof PushManage._opts.manage.afterClosePushServer === "function") {
            PushManage._opts.manage.afterClosePushServer(
                key, tip, PushManage._opts.manage.redirectToUrlAfterClose, opt.path, opt.host
            );
        }
    },
    /**
     * 获取推送服务对象
     *
     * @param {string} namespace
     * @param {object} option
     * @param {string} option.path
     * @param {string} option.host
     * @param {object} option.query
     * @returns {socket}
     */
    getPushServer: function (namespace, option) {
        let {path, host, query} = (typeof option === 'string') ? {path: option} : (option || {});
        let nsp = namespace ? (namespace.indexOf("/") !== 0 ? "/" + namespace : namespace) : "/";
        let opt = getOpt(nsp, path, host);
        PushManage._tryInit({
            path: opt.path,
            host: opt.host,
            query: query
        });
        if (PushManage._sockets[opt.id]) {
            return PushManage._sockets[opt.id];
        }
        if (nsp === '/') {
            PushManage._sockets[opt.id] = sio("//" + opt.host + nsp, Object.assign({}, PushManage._opts.connect, {
                path: opt.path,
                query: query
            }));
        } else {
            let manage = PushManage._sockets[getOpt('/', path, host).id].io;
            PushManage._sockets[opt.id] = manage.socket(nsp, {query: query || manage.opts.query});
        }
        return PushManage._sockets[opt.id].on("error", function (reason) {
            PushManage._onError(reason, opt.path, opt.host);
        });
    }
};

export default {
    /**
     * 设置默认参数（注：每个页面，只需调用一次就可）
     * @param manageOpt
     * @param connectOpt
     */
    setup (manageOpt, connectOpt) {
        manageOpt && Object.assign(PushManage._opts.manage, manageOpt);
        connectOpt && Object.assign(PushManage._opts.connect, connectOpt);
    },
    closePushServer: PushManage.closePushServer,
    getPushServer: PushManage.getPushServer,
    PushTimer: PushTimer
};
