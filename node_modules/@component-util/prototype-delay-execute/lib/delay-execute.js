/*!
 * Copyright (c) 2010-2017 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2017 湖南蚁坊软件有限公司。保留所有权利。
 */

"use strict";

/**
 * 当前函数, 延迟执行的一个包装
 * 使用方法:
 *
 * var fn = function(){};
 * $(window).on('resize', fn.delayExecute(oThis, 1000, false));
 *
 * Created by wuyaoqian on 16/6/17.
 */

/**
 * 当前函数, 延迟执行的一个函数封装
 * @param delay {int} 延迟执行的毫秒数
 * @param executePosition {object} {
 *      // 是否在 timeout 前执行
 *      before:false,
 *      // 是否在 timeout 后执行（注意：当 before 为 false 时，after 将强制为 true, 要不然就没地方可以执行了）
 *      after:true
 * }
 * @returns {Function}
 */
Function.prototype.delayExecute = function (delay, executePosition) {
    let timeout = false, later = this, context, args, boundFN = function () {
        later.apply(context, args);
    }, position = Object.assign({
        before: false,
        after: false
    }, executePosition);
    // 如果 executePosition = true ，就 position.before = true
    if (executePosition === true) {
        position.before = true;
    }
    // 当 before 为 false 时，after 将强制为 true
    if (!position.before) {
        position.after = true;
    }
    return function () {
        context = this;
        args = arguments;
        if (timeout) { clearTimeout(timeout); }
        if (position.before) {
            if (!timeout) { boundFN(); }
            timeout = setTimeout(function () {
                timeout = false;
                if (position.after) { boundFN(); }
            }, delay);
        } else {
            timeout = setTimeout(boundFN, delay);
        }
    };
};