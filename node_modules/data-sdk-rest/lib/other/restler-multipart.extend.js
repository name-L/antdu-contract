/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 扩展附件上传 -- 直接将浏览器中的上传，代理到数据部
 * 扩展附件下载 -- 直接将数据部中的下载，代理到浏览器
 * 请求的代理扩展实现 pipe-request, pipe-response
 *
 * Created by wuyaoqian on 15/4/1.
 */

// const logger = require("log4js-config").get("eefung.data-sdk-webapp." + require('path').basename(__filename));

function exceedMaxUploadSize (browserRequest, instance, maxSize, size) {
    if (typeof browserRequest.pause === 'function') {
        browserRequest.pause();
    }
    instance.abort();
    instance._fireCancelTimeout();
    const errorCodeDesc = {
        'errorCode': 'exceed-max-upload-size',
        'data': {
            max: maxSize,
            cur: size
        }
    };
    const customResponse = {
        statusCode: 500,
        raw: '这是SDK抛出的自定义请求上传超过最大限定值错误（max: ' + maxSize + ', cur: ' + size + '）'
    };
    instance.emit('error', errorCodeDesc, customResponse);
    instance.emit('complete', errorCodeDesc, customResponse);
}

function extendRestlerRequest (Request) {
    // 1. 扩展 run 方法
    let oldRun = Request.prototype.run;
    Request.prototype.run = function () {
        let self = this;
        let opt = self.options;
        let browserRequest = opt['req'];
        let pipeUpload = opt['pipe-upload'] || opt['pipe-request'] || opt['pipe-upload-file'];
        let maxUploadSize = Math.max(opt['max-size'], 0);
        let isNeedCompareLength = maxUploadSize && typeof maxUploadSize === 'number' && maxUploadSize > 0;
        let currentUploadLength = 0;
        let contentLength = null;
        if (browserRequest && pipeUpload) {
            // 1. 判断 content-length 是否超出 max-size 大小
            contentLength = parseInt(browserRequest.headers['content-length']);
            if (contentLength && isNeedCompareLength && contentLength > maxUploadSize) {
                return exceedMaxUploadSize(browserRequest, self, maxUploadSize, contentLength);
            }
            // 2. set browser-header (部分 header 会被排除)
            Object.keys(browserRequest.headers).forEach((key) => {
                if (
                    key === 'content-type' ||
                    key === 'content-length' ||
                    (!self.request.hasHeader(key) && key !== 'cookie')
                ) {
                    self.request.setHeader(key, browserRequest.headers[key]);
                }
            });
            // 3. operator data-event manually
            if (isNeedCompareLength) {
                browserRequest.on('data', function (chunk) {
                    currentUploadLength += chunk.length;
                    if (currentUploadLength > maxUploadSize) {
                        return exceedMaxUploadSize(browserRequest, self, maxUploadSize, currentUploadLength);
                    }
                });
            }
            // 4. start pipe body
            browserRequest.pipe(self.request);
            return self;
        }
        oldRun.apply(self, Array.prototype.slice.apply(arguments, [0]));
        return self;
    };

    // 2. 扩展 _makeRequest 方法
    let oldMakeRequest = Request.prototype._makeRequest;
    Request.prototype._makeRequest = function () {
        let originalResponseEvent;
        let self = this;
        let opt = self.options;
        let browserResponse = opt['res'];
        let pipeDownload = opt['pipe-download'] || opt['pipe-response'] || opt['pipe-response-file'];
        oldMakeRequest.apply(self, Array.prototype.slice.apply(arguments, [0]));
        originalResponseEvent = self.request._events['response'];
        self.request._events['response'] = function (dataServerResp) {
            // 0): followRedirects=true && isRedirect , 原始处理
            if (self._isRedirect(dataServerResp) && opt.followRedirects) {
                return originalResponseEvent.apply(this, Array.prototype.slice.apply(arguments, [0]));
            }

            // 1): statusCode>=400（判断依据为 restler 中的 _fireSuccess 方法中的逻辑）&& !processErrorResponsePipe => 原始处理
            if (parseInt(dataServerResp.statusCode) >= 400 && !opt.processErrorResponsePipe) {
                return originalResponseEvent.apply(this, Array.prototype.slice.apply(arguments, [0]));
            }

            // 2): 取消超时机制
            self._fireCancelTimeout();

            // 3): 处理 pipe-download 逻辑
            let downloadHeaderRet;
            let downloadHeaderObj;
            if (
                browserResponse &&
                pipeDownload &&
                (
                    // pipeDownload = true
                    (typeof pipeDownload === 'boolean' && (downloadHeaderRet = pipeDownload)) ||
                    // pipeDownload(dataServerResp.headers) = true || promise || object
                    (typeof pipeDownload === 'function' && (downloadHeaderRet = pipeDownload(
                        dataServerResp.headers, dataServerResp
                    )))
                )
            ) {
                self.emit('download-success', dataServerResp);
                if (typeof downloadHeaderRet === 'boolean') {
                    delete dataServerResp.headers['set-cookie'];
                    downloadHeaderObj = Promise.resolve(dataServerResp.headers);
                } else if (downloadHeaderRet instanceof Promise) {
                    downloadHeaderObj = downloadHeaderRet;
                } else {
                    downloadHeaderObj = Promise.resolve(downloadHeaderRet);
                }
                return downloadHeaderObj.then(function (headers) {
                    let header = headers && typeof headers === 'object' ? headers : dataServerResp.headers;
                    if (self.options['write-cookie']) {
                        header['set-cookie'] = (header['set-cookie'] || []).concat(self.options['write-cookie']);
                    }
                    browserResponse.writeHead(dataServerResp.statusCode, header);
                    dataServerResp.pipe(browserResponse);
                }, function () {
                    self.emit('response', dataServerResp);
                    self._responseHandler(dataServerResp);
                });
            }

            // 4): 处理其它默认逻辑
            self.emit('response', dataServerResp);
            self._responseHandler(dataServerResp);
        };
        return self;
    };
}

module.exports = {
    extendInit: extendRestlerRequest
};
