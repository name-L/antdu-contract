/*!
 * Copyright (c) 2010-2020 EEFUNG Software Co.Ltd. All rights reserved.
 * 版权所有 (c) 2010-2020 湖南蚁坊软件股份有限公司。保留所有权利。
 */

'use strict';

/**
 * 在 restler-base.extend.js 的基础上再次扩展 restler 使其自动加入 appToken 等想关代码
 * Created by wuyaoqian on 15/5/28.
 */

// const EventEmitter = require('events');
const baseRestler = require('./restler-base.extend.js');
const appAuthRestler = Object.assign({}, baseRestler);
const tokenProvider = require('../token/token-provider.js');
const logger = require('log4js-config').get('eefung.data-sdk-rest.' + require('path').basename(__filename));

/**
 * Restler 的一些相关扩展
 */
const RestlerExtend = {
    /**
     * 扩展 请求处理 的方法
     * @returns {RestlerOverride}
     */
    prepareRequest: function (appToken) {
        const instance = this;

        if (!appToken || !appToken.access_token) {
            logger.debug('No AppAccessToken Found In Memory, Try Next Time.');
            tokenProvider.fetchAppToken().catch(() => {});
            instance.abort();
            instance._fireCancelTimeout();
            process.nextTick(function () {
                const errorCodeDesc = {
                    'errorCode': '00116',
                    'httpStatusCode': 500,
                    'description': '请求体中没有带token',
                    'type': '公共基础异常'
                };
                const customResponse = {
                    statusCode: 500,
                    raw: '这是SDK主动抛出的自定义异常信息(AppTokenRequest) '
                };
                instance.emit('error', errorCodeDesc, customResponse);
                instance.emit('complete', errorCodeDesc, customResponse);
            });
            return instance;
        }

        // 1. 将 appAccessToken 放入请求头中（1. option: 方便下次的retry， 2. setHeader: 直接在替换当前的请求head参数）
        instance.options.headers['authorization'] = 'oauth2 ' + appToken.access_token;
        instance.request.setHeader('authorization', 'oauth2 ' + appToken.access_token);

        // 2. 定义授权出错的拦截
        const oauthProxyFail = function (errorObj, response) {
            let errorCodeNumber = (errorObj && typeof errorObj === 'object')
                ? parseInt(errorObj['error_code'] || errorObj['errorCode'])
                : false;
            if (!errorCodeNumber || !tokenProvider.isGlobalAppTokenError(errorCodeNumber)) {
                return;
            }
            instance['_process_token_validate_'] = true;
            tokenProvider.processAppTokenError(errorCodeNumber).on('token-reFetched', function (newToken) {
                delete instance['_process_token_validate_'];
                instance.options.headers['authorization'] = 'oauth2 ' + newToken.access_token;
                instance.retry();
            }).on('token-error', function (data) {
                delete instance['_process_token_validate_'];
                let ret = RestlerExtend.processFetchAppTokenError(data);
                instance.emit('fail', ret.errorCodeDesc, ret.response);
            });
        };

        // 3. 代理 complete, fail, 400, 4XX 方法，以方便对授权出错的拦截
        const executeFN = function () {
            let requestInstance = this;
            let originalCompletes = requestInstance.listeners('complete');
            let originalFails = requestInstance.listeners('fail');
            let original400 = requestInstance.listeners('400');
            let original4XX = requestInstance.listeners('4XX');
            let proxyHandler = function (handlers) {
                const requestInstance = this;
                const args = Array.prototype.slice.apply(arguments, [1]);
                if (!requestInstance['_process_token_validate_']) {
                    for (let i = 0; i < handlers.length; i++) {
                        handlers[i].apply(requestInstance, args);
                    }
                }
            };
            requestInstance._events['fail'] = [oauthProxyFail, proxyHandler.bind(requestInstance, originalFails)];
            requestInstance._events['complete'] = proxyHandler.bind(requestInstance, originalCompletes);
            requestInstance._events['400'] = proxyHandler.bind(requestInstance, original400);
            requestInstance._events['4XX'] = proxyHandler.bind(requestInstance, original4XX);
        };

        // 4. 延迟执行
        const delayRequest = instance.initDelayRequestHandle();
        process.nextTick(function () {
            delayRequest(executeFN.call(instance));
        });

        return instance;
    },
    /**
     * 处理 appToken 获取失败的返回数据处理
     * @param data
     * @return {{errorCodeDesc: *, response: *}}
     */
    processFetchAppTokenError: function (data) {
        let errorCodeDesc, customResponse;
        if (data && data.type === 'timeout') {
            errorCodeDesc = {
                'errorCode': 'request-timeout',
                'data': {
                    time: data.data
                }
            };
            customResponse = {
                statusCode: 500,
                raw: '这是SDK ( fetch appToken timeout ) 抛出的自定义请求超时: ' + (data.data / 1000) + 's'
            };
        } else {
            errorCodeDesc = {
                'errorCode': 'default-error',
                'data': {
                    error: data
                }
            };
            customResponse = {
                statusCode: 500,
                raw: '这是SDK ( fetch appToken error ) 抛出的自定义请求错误'
            };
        }
        return {
            errorCodeDesc: errorCodeDesc,
            response: customResponse
        };
    }
};

/**
 * 从 Restler 内抽取出来的，并有所改动
 */
const RestlerOverride = {
    baseRequest: function (method, url, options) {
        return RestlerExtend.prepareRequest.call(baseRestler[method](url, options), tokenProvider.appToken);
    }
};

// 重载 get、patch、post、put、del、head 方法
appAuthRestler.get = RestlerOverride.baseRequest.bind(RestlerOverride, 'get');
appAuthRestler.patch = RestlerOverride.baseRequest.bind(RestlerOverride, 'patch');
appAuthRestler.post = RestlerOverride.baseRequest.bind(RestlerOverride, 'post');
appAuthRestler.put = RestlerOverride.baseRequest.bind(RestlerOverride, 'put');
appAuthRestler.del = appAuthRestler.delete = RestlerOverride.baseRequest.bind(RestlerOverride, 'delete');
appAuthRestler.head = RestlerOverride.baseRequest.bind(RestlerOverride, 'head');

/**
 * 重新包装好后，再次Exports出去
 *
 * 方法：
 * 1. get
 * 2. patch
 * 3. post
 * 4. put
 * 5. del
 * 6. head
 */
module.exports = appAuthRestler;
